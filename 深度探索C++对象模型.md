# 深度探索C++对象模型
[![devDependency Status](https://david-dm.org/mzlogin/chinese-copywriting-guidelines/dev-status.svg)](https://david-dm.org/mzlogin/chinese-copywriting-guidelines#info=devDependencies)
-----
## 目录
<!-- vim-markdown-toc GFM -->
* [第 1 章 关于对象](#第 1 章 关于对象)
* [第 2 章 构造函数语意学](#第 2 章 构造函数语意学)
     * [2.1 默认构造函数的构造操作](2.1 默认构造函数的构造操作)
* [第 3 章 Data 语意学](#第3章 Data 语意学)
* [第 4 章 Function语意学](#第 4 章 Function 语意学)
* [第 5 章 构造、析构、拷贝语意学](#第 5 章 构造、析构、拷贝语意学)
* [第 6 章 执行期语意学](#第 6 章 执行期语意学)
* [第 7 章 站在对象模型的顶端](#第 7 章 站在对象模型的顶端)

<!-- vim-markdown-toc -->
## 第 1 章 关于对象
## 第 2 章 构造函数语意学
### 2.1 默认构造函数的构造操作 
1. 有两种常见的误解 
    - 任何类如果没有定义默认的构造函数，就会被合成出来
    - 编译器合成的默认构造函数会显式的设定每一个数据成员的默认值

2. 对于以下四种情况编译器才会合成默认构造函数
    - 父类有默认的构造函数
    >    如果一个没有任何构造函数的类派生自 “一个有默认构造函数的” 父类，那么这个派生类的默认构造函数被认为是 ”有用的（被编译器所需求）“，因此需要被合成出来。它会调用父类的默认构造函数。
 如果派生类含有多个构造函数，但其中不含默认构造函数，编译器并不会为他合成新的默认构造函数，而是会扩展每一个构造函数，将所有需要调用的默认构造函数的代码安插进去。 
    - 类中有类类型的成员函数
    >  如果类A中带有类类型成员,并且没有任何构造函数，并且这个类类型是有默认构造函数的，那么类A的默认构造函数被认为是 ”有用的“，需要合成，这个合成要在正真被调用的时候才会发生
    >  。
    - 带有虚函数的类
    >   在编译期间会发生两个扩展行动：
    1.编译器会产生一个虚表（存放着类内虚函数的地址）。
    2.在每一个类对象中，会有一个额外的虚表指针被编译器合成出来，用来指向相关虚表。
    - 带有虚基类的类
    >    虚基类的实现必须满足虚基类在其 ”每一个派生子类的对象中的位置“ 能够于执行期准备妥当。

## 第 3 章 Data 语意学
## 第 4 章 Function 语意学
## 第 5 章 构造、析构、拷贝语意学
## 第 6 章 执行期语意学
## 第 7 章 站在对象模型的顶端





