# 腾讯暑假实习生一面（C++游戏客户端开发）

1. 首先简单的介绍一下你

2. 指针和数组

   - 两者之间的区别
     - 数组一旦声明，我们不能在给他赋值，但是我们可以给指针赋值
     - 用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改
     - 用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小（单位：字节）
   - 数组是在哪个区域分配的
     - 静态数组作为局部变量时是在栈上分配到的
     - 静态数组作为全局变量时时在静态存储区
     - 动态数组是在堆上分配的

3. 空指针与野指针

   - 空指针与野指针的区别
     - 空指针不指向任何实际的对象或者函数
     - 野指针不是空指针，是一个指向垃圾内存的指针。

   - 野指针的是怎么造成的

     - 指针变量没有初始化

     - 指针被free没有delete之后，没有置为空，让人误以为这是一个合法的指针

     - 指针操作越过了变量的作用范围（访问了一个不该访问的内存），另一种情况是指针指向一个临时变量的引用，当该变量被释放时，此时的指针就变成了一个野指针 

       ~~~cpp
       A *p; // A为一个自定义对象  
       {  
           A a;  
           p = &a; // 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数  
        }  
        p->Func();  // p是“野指
       ~~~

       

   - 野指针你是怎么发现的

     会有提示警告

   - 野指针你是怎么调试出来的

     - 在VC中，在调试环境下，可以简单的通过把new替换成DEBUG_NEW来实现功能更强更方便的指针检测 
     - 重载new/delete

   - 会造成什么样的问题

     - 会造成内存泄漏问题
       - 内存泄漏是指我们在堆中申请了一块内存，但是没有去手动的释放内存，导致指针已经消失，而指针指向的东西还在，已经不能控制这块内存， 

   - 怎么解决

     - 一个指针没有指向时候置空
     - 当往一个指针分配空间时候一定呀给指针分配空间（int *p = malloc(100);返回首地址，int *p = malloc(sizeof(int)):提高代码的移植性。 ）
     - 给一个指针分配空间，一定压迫检查是否分配成功；
     - 分配空间初始化要先初始化
     - 用完后记得delete并且再次置空
     - 使用智能指针

4. 智能指针

   - 什么是智能指针

     - 所谓智能指针就是智能/自动化的管理指针所指向的动态资源的释放。它是一个类，有类似指针的功能

   - 智能指针有shared-ptr与unique_ptr底层实现

     ~~~
     当类中有指针成员时，一般有两种方式来管理指针成员：
     （1）一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；
     （2）另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享。
     　　智能指针(smart pointer)的通用实现技术是使用引用计数(reference count)。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象的指针指向同一对象。每次创建类的新对象时，初始化指针就将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，析构函数减少引用计数（如果引用计数减至0，则删除基础对象）。
     ~~~

     

   - 这两个智能指针有什么区别呢

     -  shared_ptr的实现原理是通过引用计数来实现，拷贝或赋值时将引用计数加1，析构时只有当引用计数减到0才释放空间，否则只需将引用计数减1即可. 允许多个指针指向同一个对象
     - unique_ptr独有它所指向的对象，与shared_ptr（人尽可夫）不同，unique_ptr比较霸道总裁，某个时刻只能有一个unique_ptr指向给定的对象，所以啊，当unique_ptr被销毁时，它所指向的对象也被销毁 
     - unique_ptr不支持拷贝与赋值

   - 对于对于一个unique指针，一个指向A，一个指向B会发生什么

     - A会不会释放掉

   - 对于unique指针A，B，同时指向同一个对象会发生什么

     会发生错误，不允许多个unique指针指向同一个对象

     

5. 听说你熟悉STL,你平时常用的的STL是什么

   - vector
     - vector底层实现是什么样的，他的内存是连续的么

       底层数据结构是数组、支持快速随机访问，

     - vetor是怎么进行扩容的

       1.5倍（vs下）或者2倍（gcc下），并将原来的数组的元素赋值到新数组上面去

     - 为什么要这样扩容

       采用采用成倍方式扩容，可以保证常数的时间复杂度 、空间和时间的权衡。 

     - 迭代器知道么，迭代器使用过程要注意些什么

       由于一些对容器的操作如删除元素或移动元素等会修改容器的内在状态，这会使得原本指向被移动元素的迭代器失效，也可能同时使其他迭代器失效。使用无效的迭代器是没有定义的，可能会导致和使用悬垂指针相同的问题。所以在使用迭代器编写程序时，需要特别留意哪些操作会使迭代器失效。使用无效迭代器会导致严重的运行时错误 
   - map
     - map底层是怎么实现的

       map的底层数据结构是红黑树，是有序的不重复的

       红黑树：

       ~~~
       （1）红黑树的特征是什么？
       节点是红色或黑色。
       根是黑色。
       所有叶子都是黑色（叶子是 NIL 节点）。
       每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）
       从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）
       （2）调整
       变色
       左旋
       右旋
       （3）应用
       关联数组：如 STL 中的 map、set
       ~~~

     - 为什么这样实现

6. 虚函数、多态

   - 什么是虚函数

     虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象 

   - 虚函数的实现原理

     - 简单的说，每一个虚函数的类都含有一个虚函数表，虚函数表中，其中存放着该类所有虚函数对应的函数指针

   - 多继承的实现原理

     - 每个父类都有自己虚函数表

     - 子类的成员函数放到了第一个父类的表中（按照声明顺序来判断）

       ~~~html
       
       ~~~

       

   - 基类 A、B，子类C中都有一个同名函数，如何知道自己调用的哪个函数

      当我们调用这样的函数时，应该这样ying_ying.Bear::print() :添加一个作用域

7. 多线程并发编程

   - 多线程并发编程是用在什么样的场合

     - 程序中出现需要等待的操作，比如网络操作、文件IO等，可以利用多线程充分使用处理器资源，而不会阻塞程序中其他任务的执行
     - 程序中出现可分解的大任务，比如耗时较长的计算任务，可以利用多线程来共同完成任务，缩短运算时间
     - 程序中出现需要后台运行的任务，比如一些监测任务、定时任务，可以利用多线程来完成

   - 多线程并发编程你是怎么实现

     ~~~cpp
     C++11 标准提供了一个新的线程库，内容包括了管理线程、保护共享数据、线程间的同步操作、低级原子操作等各种类。标准极大地提高了程序的可移植性，以前的多线程依赖于具体的平台，而现在有了统一的接口进行实现。
     C++11 新标准中引入了几个头文件来支持多线程编程：（所以我们可以不再使用 CreateThread 来创建线程，简简单单地使用 std::thread 即可。）
     < thread > :包含std::thread类以及std::this_thread命名空间。管理线程的函数和类在 中声明.
     < atomic > :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数。
     < mutex > :包含了与互斥量相关的类以及其他类型和函数
     < future > :包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数。
     < condition_variable > :包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。
     ~~~

     

技术无关的

1. 你的兴趣爱好是什么
2. 你会3D建模软件么
3. 你会渲染软件么
4. 学习过计算机图形学么
5. 用过游戏引擎么



最后得出的结论：你的基础还不错、就是语言表达方面有所欠缺，从跟你的谈话中并没有表现出对开发游戏很强烈的愿望，从你的简历求职意向当中并没有看出的兴趣点所在，挂了？ 没有，一面竟然让我通过了



## 别人面试过得问题

1. Struct 中不同类型的变量的内存大小问题

2. 程序需要哪三部分的内存

3. 野指针是怎么调试出来的

4. 快速排序思想

   分治法的思想

5. 哈希表与红黑树

6. 虚函数会不会影响内存大小，多个虚函数和一个

7. 虚函数内存大小是不是一样的

8. 为什么map不用哈希表要用红黑树

   ~~~html
   因为红黑树需要进行左旋，右旋操作， 而单链表不需要，
   以下都是单链表与红黑树结构对比。
   如果元素小于8个，查询成本高，新增成本低
   如果元素大于8个，查询成本低，新增成本高
   ~~~

9. 红黑树的时间复杂度(关于[红黑树的面试题](https://blog.csdn.net/gao1440156051/article/details/51581394))

   能保证在最坏情况下，基本的动态几何操作的时间均为O（lgn） 

10. 调用函数原理，结合栈来表述

    ~~~html
    实参按照从右向左的顺序一个一个进入stack中
    函数调用指令之后的“下一条指令地址”进入stack中。(pRetAddr)
    EBP(栈指针)指向调用此函数的函数栈地址。(FuncB's EBP)
    函数f中的局部变量加入到stack中。
    函数f中的局部变量从Stack中弹出。
    “下一条指令地址”从stack中弱出，流入程序计数器寄存器IP中。
    寄存器AX/EAX/RAX中的值流入到stack中h的局部变量（或者全局变量等）中。(返回值)
    调用函数f时的实参从stack中弹出。
    ~~~

11. 对游戏开发你有什么了解
