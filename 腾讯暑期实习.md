# 腾讯暑假实习生面试（C++游戏客户端开发）

## 一面

1. 首先简单的介绍一下你

2. 指针和数组

   - 两者之间的区别
     - 数组一旦声明，我们不能在给他赋值，但是我们可以给指针赋值
     - 用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改
     - 用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小（单位：字节）
   - 数组是在哪个区域分配的
     - 静态数组作为局部变量时是在栈上分配到的
     - 静态数组作为全局变量时时在静态存储区
     - 动态数组是在堆上分配的

3. 空指针与野指针

   - 空指针与野指针的区别
     - 空指针不指向任何实际的对象或者函数
     - 野指针不是空指针，是一个指向垃圾内存的指针。

   - 野指针的是怎么造成的

     - 指针变量没有初始化

     - 指针被free没有delete之后，没有置为空，让人误以为这是一个合法的指针

     - 指针操作越过了变量的作用范围（访问了一个不该访问的内存），另一种情况是指针指向一个临时变量的引用，当该变量被释放时，此时的指针就变成了一个野指针 

       ~~~cpp
       A *p; // A为一个自定义对象  
       {  
           A a;  
           p = &a; // 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数  
        }  
        p->Func();  // p是“野指
       ~~~

       

   - 野指针你是怎么发现的

     会有提示警告

   - 野指针你是怎么调试出来的

     - 在VC中，在调试环境下，可以简单的通过把new替换成DEBUG_NEW来实现功能更强更方便的指针检测 
     - 重载new/delete

   - 会造成什么样的问题

     - 会造成内存泄漏问题
       - 内存泄漏是指我们在堆中申请了一块内存，但是没有去手动的释放内存，导致指针已经消失，而指针指向的东西还在，已经不能控制这块内存， 

   - 怎么解决

     - 一个指针没有指向时候置空
     - 当往一个指针分配空间时候一定呀给指针分配空间（int *p = malloc(100);返回首地址，int *p = malloc(sizeof(int)):提高代码的移植性。 ）
     - 给一个指针分配空间，一定压迫检查是否分配成功；
     - 分配空间初始化要先初始化
     - 用完后记得delete并且再次置空
     - 使用智能指针

4. 智能指针

   - 什么是智能指针

     - 所谓智能指针就是智能/自动化的管理指针所指向的动态资源的释放。它是一个类，有类似指针的功能

   - 智能指针有shared-ptr与unique_ptr底层实现

     ~~~
     当类中有指针成员时，一般有两种方式来管理指针成员：
     （1）一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；
     （2）另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享。
     　　智能指针(smart pointer)的通用实现技术是使用引用计数(reference count)。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象的指针指向同一对象。每次创建类的新对象时，初始化指针就将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，析构函数减少引用计数（如果引用计数减至0，则删除基础对象）。
     ~~~

     

   - 这两个智能指针有什么区别呢

     -  shared_ptr的实现原理是通过引用计数来实现，拷贝或赋值时将引用计数加1，析构时只有当引用计数减到0才释放空间，否则只需将引用计数减1即可. 允许多个指针指向同一个对象
     -  unique_ptr独有它所指向的对象，与shared_ptr（人尽可夫）不同，unique_ptr比较霸道总裁，某个时刻只能有一个unique_ptr指向给定的对象，所以啊，当unique_ptr被销毁时，它所指向的对象也被销毁 
     -  unique_ptr不支持拷贝与赋值

   - 对于对于一个unique指针，一个指向A，一个指向B会发生什么

     - A会不会释放掉

   - 对于unique指针A，B，同时指向同一个对象会发生什么

     会发生错误，不允许多个unique指针指向同一个对象

     

5. 听说你熟悉STL,你平时常用的的STL是什么

   - vector
     - vector底层实现是什么样的，他的内存是连续的么

       底层数据结构是数组、支持快速随机访问，

     - vetor是怎么进行扩容的

       1.5倍（vs下）或者2倍（gcc下），并将原来的数组的元素赋值到新数组上面去

     - 为什么要这样扩容

       采用采用成倍方式扩容，可以保证常数的时间复杂度 、空间和时间的权衡。 

     - 迭代器知道么，迭代器使用过程要注意些什么

       由于一些对容器的操作如删除元素或移动元素等会修改容器的内在状态，这会使得原本指向被移动元素的迭代器失效，也可能同时使其他迭代器失效。使用无效的迭代器是没有定义的，可能会导致和使用悬垂指针相同的问题。所以在使用迭代器编写程序时，需要特别留意哪些操作会使迭代器失效。使用无效迭代器会导致严重的运行时错误 
   - map
     - map底层是怎么实现的

       map的底层数据结构是红黑树，是有序的不重复的

       红黑树：

       ~~~
       （1）红黑树的特征是什么？
       节点是红色或黑色。
       根是黑色。
       所有叶子都是黑色（叶子是 NIL 节点）。
       每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）
       从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）
       （2）调整
       变色
       左旋
       右旋
       （3）应用
       关联数组：如 STL 中的 map、set
       ~~~

     - 为什么这样实现

6. 虚函数、多态

   - 什么是虚函数

     虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象 

   - 虚函数的实现原理

     - 简单的说，每一个虚函数的类都含有一个虚函数表，虚函数表中，其中存放着该类所有虚函数对应的函数指针

   - 多继承的实现原理

     - 每个父类都有自己虚函数表

     - 子类的成员函数放到了第一个父类的表中（按照声明顺序来判断）

       ~~~html
       
       ~~~

       

   - 基类 A、B，子类C中都有一个同名函数，如何知道自己调用的哪个函数

      当我们调用这样的函数时，应该这样ying_ying.Bear::print() :添加一个作用域

7. 多线程并发编程

   - 多线程并发编程是用在什么样的场合

     - 程序中出现需要等待的操作，比如网络操作、文件IO等，可以利用多线程充分使用处理器资源，而不会阻塞程序中其他任务的执行
     - 程序中出现可分解的大任务，比如耗时较长的计算任务，可以利用多线程来共同完成任务，缩短运算时间
     - 程序中出现需要后台运行的任务，比如一些监测任务、定时任务，可以利用多线程来完成

   - 多线程并发编程你是怎么实现

     ~~~cpp
     C++11 标准提供了一个新的线程库，内容包括了管理线程、保护共享数据、线程间的同步操作、低级原子操作等各种类。标准极大地提高了程序的可移植性，以前的多线程依赖于具体的平台，而现在有了统一的接口进行实现。
     C++11 新标准中引入了几个头文件来支持多线程编程：（所以我们可以不再使用 CreateThread 来创建线程，简简单单地使用 std::thread 即可。）
     < thread > :包含std::thread类以及std::this_thread命名空间。管理线程的函数和类在 中声明.
     < atomic > :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数。
     < mutex > :包含了与互斥量相关的类以及其他类型和函数
     < future > :包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数。
     < condition_variable > :包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。
     ~~~

     

技术无关的

1. 你的兴趣爱好是什么
2. 你会3D建模软件么
3. 你会渲染软件么
4. 学习过计算机图形学么
5. 用过游戏引擎么



最后得出的结论：你的基础还不错、就是语言表达方面有所欠缺，从跟你的谈话中并没有表现出对开发游戏很强烈的愿望，从你的简历求职意向当中并没有看出的兴趣点所在，挂了？ 没有，一面竟然让我通过了



## 别人面试过得问题

1. Struct 中不同类型的变量的内存大小问题

   先按照自身进行对齐，并且内存必须是内存最大的整数倍

2. 程序需要哪三部分的内存

3. 野指针是怎么调试出来的

   重载运算符new/delete

4. 快速排序思想

   分治法的思想

   每次排序都能固定好一个函数的位置

5. 哈希表与红黑树

6. 虚函数会不会影响内存大小，多个虚函数和一个

   虚函数不会影响内存的大小

7. 虚函数内存大小是不是一样的

   虚函数的大小是一样的

8. 为什么map不用哈希表要用红黑树

   ~~~html
   因为红黑树需要进行左旋，右旋操作， 而单链表不需要，
   以下都是单链表与红黑树结构对比。
   如果元素小于8个，查询成本高，新增成本低
   如果元素大于8个，查询成本低，新增成本高
   ~~~

9. 红黑树的时间复杂度(关于[红黑树的面试题](https://blog.csdn.net/gao1440156051/article/details/51581394))

   能保证在最坏情况下，基本的动态几何操作的时间均为O（lgn） 

10. [调用函数原理](https://blog.csdn.net/weixin_36725931/article/details/85208168)

  ~~~
  第一步，函数参数入栈
  第二步，返回地址入栈，准备跳转。调用 call 指令
  第三步，保存原栈帧的栈底地址，通过特定的两个寄存器之间赋值来设置新栈帧的栈底地址，通过修改特定一个寄存器值来设置新栈帧的栈顶地址，然后正式执行函数。
  第四步，销毁新栈帧的局部变量空间，恢复原栈帧的栈底地址，往特定寄存器装载返回地址，销毁函数参数空间，前四部都完成后原栈帧的栈底地址也能恢复
  ~~~

11. 对游戏开发你有什么了解

12. OPenGL的渲染管线

13. 光栅化在哪一阶段

14. 什么是延迟渲染

15. 深度测试过程；透视变换后，为什么每个分量要除以W

16. 纹理采样的特点

17. C++与C的不同之处

    面向对象，面向过程结构化语言

    运算符重载，多态等等

18. C++面向对象有哪些特征

19. C++是如何实现多态的

    在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数 

20. 什么是内联函数，内联函数能不能用递归

    **函数调用**：函数的调用是需要付出一定的时空开销的,因为系统在调用函数时,要保留现场,然后转入被调用函数去执行,调用完,再返回主调函数,此时再恢复现场,这些操作,显然在宏中是没有的

    **内联函数与宏的区别**：宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。 

    内联机制被引入到C++作为对宏机制的改进和补充。内联函数的参数传递机制与普通函数相同。但是编译器会在每处调用内联函数的地方将内联函数的内容展开，这样避免了函数调用的开销。

    内联函数不能自己调用自己

21. 函数的执行过程

22. C++各个变量分布在内存的哪些部分

23. C++程序的编译过程

    预处理、编译、汇编、链接

24. 静态链接与动态链接的区别

    

25. 什么是死锁，避免死锁的方法有哪一些

26. TCP/UDP的区别？TCP为什么能保证有效传输，TCP的三次握手 

## 二面

1. 什么情况下会发生堆栈溢出

   1.函数调用层次太深。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。 
   2.动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。 
   3.数组访问越界。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。 
   4.指针非法访问。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。

2. 虚函数调用的内存开销，与普通函数有什么区别

3. 函数是如何在栈中调用的

4. 联合体的内容
   - 是一种特殊的类，可以在其中定义多种不同的数据类型
   - 这些数据共享一段内存，在不同的时间里保存不同的数据类型和长度的变量以达到节省空间的目的。但同一时间内只能存储其中一个成员变量的值
   - 可以用union判断系统是大端还是小端
   - union变量公用内存，应该以最长的为准

5. QT有没有研究源码，信号与槽的底层实现

6. 如果是你怎么设计信号与槽机制

7. 有没有研究过其他源码

8. 说说图像处理滤波函数的作用原理

9. 高斯滤波使用来解决什么样的问题

10. canny边缘检测与sobel，拉普拉斯之间有什么区别

11. canny运行计算要多长时间，你怎么缩短运算时间

12. 为什么这么设计，这样设计是为什么基于什么样的原理

13. 四元数，四元数在3D数学中的应用
