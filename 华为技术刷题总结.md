## 	华为技术刷题总结

1.字符串最后一个单词的长度

~~~cpp
/*使用动态数组来做，输入的字符串依次存入数组中，
最后返回数组中最后一个元素（字符串）的长度*/
#include<iostream>
#include<string>
#include<vector>
 
using namespace std;
 
int main(){
    string input;
    vector<string>arr;
    while(cin>>input){//只存入最后一个空白字符以后的字符串，因此是不严谨的
        arr.push_back(input);
    }
    cout<<arr[arr.size()-1].length()<<endl; //输入流会直接记录最后一个字符串，因为单词之间是用空格隔开的   
    return 0;
}
~~~

~~~cpp
//这是比较严谨的做法
// C++
//有些同学的答案没考虑到末尾有空格的情况，对于末尾有空格的都输出为0了。
//“hello world     ”依然输出5.
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string s;
    while(getline(cin,s)){
        int n=0,flag=1;
        for(int i=s.length()-1;i>=0;--i){//倒着计算
            if(flag && s[i]==' '){//如果末尾有空格，先清除末尾空格
                continue;
            }
            else if(s[i]!=' '){
                flag = 0;
                ++n;
            }
            else{
                break;
            }
        }
        cout << n << endl;
    }
    return 0;
}
~~~

2.计算字符的个数（简单）  

注意不区分大小写,令人费解的是用由空格的字符串，真是醉了

~~~cpp
#include<iostream>
#include<string>

using namespace std;

int main(){
    string str;
    while(cin>>str){
        char ch;
        cin>>ch;
        int count = 0;
        for(int i = 0; i<str.size();i++){
            if(tolower(str[i])==tolower(ch))
                count++;
        }
        cout<<count<<endl;
    }
}
~~~



3.明明的随机数，就是去重（简单）

~~~cpp
//类似于计数排序的那种
#include <iostream>
using namespace std;
int main() {
    int N, n;
    while (cin >> N) {
        int a[1001] = { 0 };
        while (N--) {
            cin >> n;
            a[n] = 1;
        }
        for (int i = 0; i < 1001; i++)
            if (a[i])
                cout << i << endl;
    }
    return 0;
}//阿西吧
~~~

4.字符串分割

~~~cpp
//特别精辟的解法，用substr函数
#include <iostream>
#include <string>
using namespace std;
 
int main(){
    string str;
     
    while(getline(cin,str)){
        while(str.size()>8){
            cout << str.substr(0,8) <<endl;//从第0号位置取，截取长度是8
            str=str.substr(8);//从第8号位置后面的字符串
        }
         //不够8位的补0
    }
}
//相对比较严谨的做法
#include <iostream>
#include <string>
using namespace std;
void fuck(string str) {
    if (str == "")
        return;
    if (str.size() <= 8) {
        str.append(8 - str.size(), '0');
        cout << str << endl;
        return;
    }
    cout << str.substr(0, 8) << endl;
    fuck(str.substr(8));
}
int main() {
    string str1, str2;
    cin >> str1 >> str2;
    fuck(str1);
    fuck(str2);
    return 0;
}

~~~

5.进制转换

将16进制转化为十进制

~~~cpp
//十六进制数 hex，八进制数，ocx；二进制没有默认的转换
#include <iostream>
using namespace std;

int main()
{
    int a;
    while(cin>>hex>>a){
    cout<<a<<endl;
    }
}

//递归输出二进制
void BinaryRecursion(int n)  
{  
 int a;  
 a=n%2;  
 n=n>>1;  
 if (n==0)  
     ;  
 else  
  BinaryRecursion(n);  
 cout<<a;  
} 
~~~

6.质数因子

需要把所有质数求出来（带有重复）

~~~cpp
#include <iostream>
 
using namespace std;
 
int main(void)
{
    long input;
    //cin >> input;
    while (cin >> input)
    {
        while (input != 1)
        {
            for (int i = 2; i <= input; i++)
            {
                if (input % i == 0)
                {
                   input /= i;
                   cout << i << ' ';
                    break;
                }
            }
        }    
    ]
    return 0;
}
~~~

7.取近视值

~~~cpp
#include <iostream>
using namespace std;
int main()
{
float a;
cin>>a;
cout<<int(a+0.5);
return 0;
}
~~~

8.合并表记录

~~~cpp
//C++ //C++，用stl中的map
#include<iostream>
#include<map>
using namespace std;
 
int main()
{
    int n;
    while(cin >> n){
        map<int,int> m;
        while(n--){
            int key,value;
            cin >> key >> value;
            if(!m[key]){
                m[key] = value;
            }
            else m[key] += value;//不存在时赋值，存在时累加
        }
        //map内部本身就是按照key的大小顺序进行存储的
        for(map<int,int>::iterator it=m.begin();it!=m.end();++it){
            cout << it->first << " "<< it->second << endl;
        }
    }
    return 0;
}
~~~

9.提取不重复的整数

~~~cpp
#include<iostream>
using namespace std;
int main()
{
    int n;
    int a[10]={0};
    int num=0;
    cin>>n ;
    while(n)
    {
        if(a[n%10]==0)
        {
            a[n%10]++;//这一步是更新，遇到下次相同的数会跳过
            num=num*10+n%10;
        }
        n/=10;
    }
    cout<<num<<endl;     
    return 0;
}
//当然，输入数组也可以以字符串的形式输入
#include <iostream>
#include <string>
using namespace std;
int main()
{
    int m, i;
    int a[10] = {0};
    string str;
    getline(cin, str);
    m = str.size();
    for (i = m - 1; i >= 0; i--)
    {
        if (a[str[i] - '0'] == 0)
        {
            cout << str[i];
            a[str[i] - '0']++;//类似于计数排序的思想
        }
    }
    return 0;
}
~~~

10.字符个数统计

~~~cpp
/*C++
输入字符，ascii值在[0,127]时插入集合set中，输出set中的元素个数。*/
#include<iostream>
#include<set>
using namespace std;
int main()
{
    char c;
    set<char> s;
    while(cin>>c){
        if(c>=0 && c<=127){
            s.insert(c);
        }
    }
    cout << s.size() <<endl;
}
~~~

11.数字颠倒

~~~CPP
//数字转换为字符类型+'0'
#include<iostream>
 
using namespace std;
 
int main(){
    int n;
    cin>>n;
    char tmp;
    while(n){
        tmp=n%10 + '0';
        cout<<tmp;
        n/=10;
    }
    return 0;
}

~~~

12.字符串反转（简单）

13.句子逆序

~~~cpp
//使用stringstream，分割字符
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
 
int main() {
    string s;
    getline(cin,s);
    stringstream ss(s);
    string res="", tmp;
    while (ss>>tmp) {
        if (res=="")
            res=tmp;
        else
            res=tmp+" "+res;
    }
    cout<<res;
    return 0;
}
~~~

14.字符串的连接最长路径查找

~~~cpp
#include<iostream>
#include<string>
#include<algorithm>
#include<vector>
using namespace std;
int main(){
    int num;
    vector<string>vec;
    cin >> num;
    while(num){
        string str;
        cin>>str;
        vec.push_back(str);
        num--;
    }
    sort(vec.begin(),vec.end());
    for(int i = 0;i < vec.size();i ++){
        cout<<vec[i]<<endl;
    }
    return 0;
}
~~~

15.求int 型整数转化为二进制1的个数（简单，主要是正整数）

16.购物单（有附加条件的01背包问题）比较难

~~~cpp
#include <iostream>
#include <string>
using namespace std;
 
int getMax(int x, int y){
    return (x > y ? x : y);
}
 
int main(){
    int N;  //总钱数
    int m;  //希望购买的物品个数
    int weight[60][3]={0};  //价格（成本）
    int value[60][3]={0};   //价值（重要度*价格）
    int f[60][3200];        //第i个物品在j容量下可以获得的最大价值
    int i,j;
 
    cin >> N >> m;
    N/=10;  //都是10的整数，先除以10，减少循环次数
    //存储清单
    for(int i=1;i<=m;i++){
        int v;  //该物品价格
        int p;  //该物品价值
        int q;  //该物品主件还是附件
        cin >> v >> p >> q;
        v/=10;
 
        if(q==0){               //主件
            weight[i][0]=v;
            value[i][0]=p*v;
        }
        else{                   //附件
            if(weight[i][1]==0){    //第一个附件
                weight[i][1]=v;
                value[i][1]=p*v;   
            }
            else{                   //第二个附件
                weight[i][2]=v;
                value[i][2]=p*v;
            }
        }
    }
    //遍历计算
    for(i=1;i<=m;i++)
        for(j=N;j>0;j--){
            if(j>=weight[i][0])      //可以容下第i个主件时,比较放第i个或者不放第i个物品的价值
                f[i][j]=getMax(f[i-1][j],f[i-1][j-weight[i][0]]+value[i][0]);
            if(j>=weight[i][0]+weight[i][1]) //可以容下第i个主件和此主件的第1个附件时
                f[i][j]=getMax(f[i-1][j],f[i-1][j-weight[i][0]-weight[i][1]]+value[i][0]+value[i][1]);
            if(j>=weight[i][0]+weight[i][2]) //可以容下第i个主件和此主件的第2个附件时
                f[i][j]=getMax(f[i-1][j],f[i-1][j-weight[i][0]-weight[i][2]]+value[i][0]+value[i][2]);
            if(j>=weight[i][0]+weight[i][1]+weight[i][2])        //可以容下第i个主件和此主件的第1个附件和第2个附件时
                f[i][j]=getMax(f[i-1][j],f[i-1][j-weight[i][0]-weight[i][1]-weight[i][2]]+value[i][0]+value[i][1]+value[i][2]);
        }
    cout << f[m][N]*10 << endl;
}
~~~



17.坐标移动

~~~cpp
//关于这里有两个函数 find_first_of
#include<iostream>
#include<string>
#include<cstddef>   //std::size_t
using namespace std;
 
int main()
{
    string str;
    while(cin>>str){
        pair<int,int> point(0,0);               //point.first point.second
        size_t found = str.find_first_of(';');  //找到第一个';'的位置
        int start = 0;
        while(found!=string::npos){
            string s1 = str.substr(start,found-start);
            //cout << s1 << endl;
            start = found+1;
            found = str.find_first_of(';',found+1);//更新found的位置，即从found+1找第一个;的位置
 
            if(s1.size()>1 && s1.size()<=3){    //合法的字符个数：2或3
                char c = s1[0];
                int n = 0;
                int invalid = 0;    //数字为是否非法
                for(int i=1; i<s1.size(); ++i){ //数字位判断与提取，A1A
                    if(s1[i]>='0'&&s1[i]<='9')
                        n = n*10 + (s1[i]-'0');
                    else{
                        invalid=1;
                        break;
                    }
                }
                if(invalid==0){
                    switch(c)
                    {
                        case 'A': {point.first-=n;break;}
                        case 'D': {point.first+=n;break;}
                        case 'W': {point.second+=n;break;}
                        case 'S': {point.second-=n;break;}
                    }
                }
 
            }
        }
        cout << point.first << ',' << point.second <<endl;
    }
    return 0;
}
~~~

18.识别有效的IP地址和掩码并进行分类统计,贼几把啰嗦，没做，懒得看

19.简单错误记录

20.密码验证合格程序（难，主要是最后一个条件，，不能有相同长度超2的子串重复）

~~~cpp
//头文件：#include <ctype.h>
//isAalpha(),isDigit()
#include <iostream>
#include <string>
using namespace std;
int main(){
    string str;
    while(cin >> str){
        int flag[4] = {0};
        if(str.size() <= 8) goto NG;//长度超过8
        for(int i = 0; i < str.size(); ++i)//是数字，子母门，其他符号三种，isAalpha(),isDigit()
            if(str[i] >= 'a' && str[i] <= 'z') flag[0] = 1;
            else if(str[i] >= 'A' && str[i] <= 'Z') flag[1] = 1;
            else if(str[i] >= '0' && str[i] <= '9') flag[2] = 1;
            else flag[3] = 1;
        if(flag[0] + flag[1] + flag[2] + flag[3] < 3) goto NG;
        for(int i = 0; i <= str.size()-6; i++)//是否有重复的子串
            for(int j = i+3;j < str.size();j++)
                if(str[i] == str[j] && str[i+1] == str[j+1] &&str[i+2] == str[j+2]) goto NG;
        OK:
        cout << "OK" << endl;continue;
        NG:
        cout << "NG" << endl;
    }
    return 0;
}//我的是最短的吗？
~~~

21.简单密码的破解

就是他妈的字母表查找，完美

~~~cpp
#include<iostream>
#include<string>
using namespace std;
const string dict1="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
const string dict2="bcdefghijklmnopqrstuvwxyza22233344455566677778889999";
 
char Char_Change(char a){
    for(int i=0;i<dict1.size();i++)
        if(dict1[i]==a) return dict2[i];
    return a;
}
 
int main(){
    //string data="YUANzhi1987";
    string data;
    while(getline(cin,data)){
        for(int i=0;i<data.size();i++)
            data[i] = Char_Change(data[i]);
        cout<<data<<endl;
    }
    return 0;
}
~~~

22.汽水瓶

分析问题就行

~~~cpp
//标准解法

#include<iostream>
#include<vector>

using namespace std;

int main(){
    int num;    
    while(cin>>num){
        int count = 0;
            while(num>=3){
                int less = num % 3;
                num = num /3;
                count+=num;
                num = num+less;
            }
        if(num == 2)
            count++;
                cout<<count<<endl;      
    }    
    return 0;
}
//找规律解法
能喝的瓶数=目前空瓶数除以2
#include <iostream>
using namespace std;
int main(int argc,char *argv[]){
    int n;
    while(cin>>n){
            cout<<n/2<<endl;
    }
    return 0;
}

~~~

23.删除字符串中出现次数最少的字符

~~~cpp
//第一步、循环找到次数最少的所有字符
//第二步、遍历字符串，如果该字符串小于，大于将其输出
#include <iostream>
#include <string>
using namespace std;
int main()
{
    int i, m,min;
    int a[26];
    string str,temp;
    while (cin >> str)
    {
        for (int i = 0; i < 26; i++)
            a[i] = 0;
 
        m = str.size();
        for (i = 0; i<m; i++)
            a[str[i]-'a']++;
        min = a[str[0]-'a'];
        for (i = 0; i<m; i++)
        if (a[str[i] - 'a'] <= min)
            min = a[str[i]-'a'];
        for (i = 0; i < m; i++)
        if (a[str[i] - 'a'] > min)
            cout << str[i];
 
        cout << endl;
    }  
    return 0;
}

~~~

24.合唱队

~~~cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
 
// 基本思路，两遍最长递增子序列，并找和最大
int main(void)
{
    int n;
    while (cin >> n)
    {
        int tmp;
        vector<int> queue;
        vector<int> dp_1(n, 1);
        vector<int> dp_2(n, 1);
         
        for (int i = 0; i < n; ++i)
        {
            cin >> tmp;
            queue.push_back(tmp);
        }
 
        // 第一遍dp
        for (int i = 0; i < n; ++i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                if (queue[i] > queue[j] && dp_1[i] < dp_1[j] + 1)
                    dp_1[i] = dp_1[j] + 1;
            }
        }
 
        std::reverse(queue.begin(), queue.end());
        // 第二遍dp
        for (int i = 0; i < n; ++i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                if (queue[i] > queue[j] && dp_2[i] < dp_2[j] + 1)
                    dp_2[i] = dp_2[j] + 1;
            }
        }
        std::reverse(dp_2.begin(), dp_2.end());
 
        int max = -1;
        int sum;
        for (int i = 0; i < n; ++i)
        {
            sum = dp_1[i] + dp_2[i];
            if (sum > max)
            {
                max = sum;
            }
        }
        cout << n - max + 1 << endl;
    }
    return 0;
}
~~~

25.数据分类（题目都看不懂）

26.字符串排序

~~~cpp
#include<vector>
#include<iostream>
#include<string>
 
using namespace std;
 
int main()
{
    string s;
    vector<char> tempChar;
    while(getline(cin,s))
    {
        tempChar.clear();
        int len = s.size();
        for(int j=0; j<26; j++)
        {
            for(int i=0; i<len; i++)
            {
                if(s[i]-'a'==j||s[i]-'A'==j)
                {
                    tempChar.push_back(s[i]);
                }
            }
        }
        for(int i=0,k=0;(i<len)&&k<tempChar.size();i++)
        {
            if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z'))
                s[i]=tempChar[k++];
        }
        cout<<s<<endl;
    }
    return 0;
}

~~~

 27.查找兄弟单词

~~~cpp
#include<iostream>
#include<string>
#include<map>
#include<vector>
#include<algorithm>
using namespace std;
bool isBrother(string str, string s){
    if(str.size() == s.size()){
        if(str == s)
            return false;
        sort(str.begin(), str.end());
        sort(s.begin(), s.end());
        if(str == s)
            return true;
    }
    return false;
}
int main(){
    int num;
    
    while(cin>> num){
        string tmp;
        string str;
        int k;
        vector<string>vec;
        string res;
        for(int i = 0; i < num; ++i){
            cin >> tmp;
            vec.push_back(tmp);
        } 
         sort(vec.begin(), vec.end());
         cin>>str;
         cin>>k;
         int count =0;
    for(int i = 0; i< vec.size();i++){
        if(isBrother(vec[i],str)){
             count++;
             if(k == count)
                 res = vec[i];
          }
    }
       if(!vec.empty())
            cout << count << endl;
        if(count >= k)
            cout << res << endl;
      }
    
    return 0;
}
~~~

28.素数伴侣（比较难）从语言库知多少到算法值多少

29.字符串合并处理

~~~cpp
//查找表？？？
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
const string helper1 = "0123456789abcdefABCDEF";
const string helper2 = "084C2A6E195D3B7F5D3B7F";
int main(){
    string str1, str2;
    while(cin>>str1>>str2){
       // getline(cin,str2);
        string s, s1, s2;      
        s = str1 + str2;
        int len = s.size();
        for(int i = 0; i < len; ++i){
            if(i % 2 == 0)
                s1 += s[i];
            else
                s2 += s[i];
        }
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());
        s.clear();
        for(int i = 0,j = 0, k = 0; i < len; ++i){
            if(i % 2 == 0)
                s += s1[j++];
            else
                s += s2[k++];
        }
        for(int i = 0; i < len; ++i){
            int n = helper1.find(s[i]);
            if(n != -1)
                s[i] = helper2[n];
        }
        cout << s << endl;
    }
    return 0;
}

~~~

30.单词倒排（中级）

这里主要是有中间有多个间隔字符的状况

~~~cpp
/*思路：从前往后扫描字符串，遇到是单词就入vector，最后反向输出即可*/
#include<iostream>
#include<vector>
#include<string>
using namespace std;
int main()
{
    string str;
    while(getline(cin,str))
    {
        vector<string>svec;
        svec.clear();
        string temp="";
        for(int i=0;i<str.size();++i)
        {
            if(str[i]>='a' && str[i]<='z' || str[i]>='A' && str[i]<='Z')
                temp+=str[i];
            else
            {
                if(temp.size()>0)
                {
                    svec.push_back(temp);
                    temp="";
    }
   }
  }
        if(temp.size()>0)
            svec.push_back(temp);
        for(int i=svec.size()-1;i>0;--i)
            cout<<svec[i]<<' ';
  cout<<svec[0]<<endl;       
 }
    return 0;
}
~~~

31.字符串运用-密码截取

~~~cpp
#include<iostream>
#include <string>
using namespace std;
 
int main(){
    string s;
    while(cin>>s){
        const int len = s.size();
        if(len <= 1) return -1;
        int maxLen = 0;
        for(int i = 1; i < len; i++){
            //寻找以i-1,i为中点偶数长度的回文
            int low = i-1, high = i;
            while(low >= 0 && high < len && s[low] == s[high]){
                 low--; high++;
            }
            if(high - low - 1 > maxLen)
               maxLen = high - low -1;
            //寻找以i为中心的奇数长度的回文
            low = i- 1; high = i + 1;
            while(low >= 0 && high < len && s[low] == s[high]){
                low--; high++;
            }
            if(high - low - 1 > maxLen)
               maxLen = high - low -1;
        }
        cout<<maxLen<<endl;
    }
    return 0;
}
~~~

32.整数与IP地址间的转换

~~~cpp
#include <iostream>
using namespace std;
int main()
{
    long long n, a1, a2, a3, a4;
    char ch;
    while(cin >> a1 >> ch >> a2 >> ch >> a3 >> ch >> a4)
    {
        cin >> n;
        long long res = 0;
        res += (a1 << 24)  + (a2 << 16) + (a3 << 8)  + a4;
        a1 = n >> 24;
        a2 = (n >> 16) & 255;
        a3 = (n >> 8) & 255;
        a4 = n & 255;
        cout << res << endl << a1 << '.' << a2 << '.' << a3 << '.' << a4 << endl;
    }
    return 0;
}
~~~

33.图片整理(简单，直接Sort)

按照字符大小进行排序

34.蛇型矩阵

~~~cpp
#include <stdio.h>
#include <iostream>
#include <string>
using namespace std;
 
 
int main()
{
    int n;
    while (cin>>n)
    {
        int beg=1;
        for(int i=1;i<=n;i++)
        {
            cout<<beg;
            int tmp = beg;
            for(int j=i+1;j<=n;j++)
            {
                tmp+=j;
                cout<<" "<<tmp;              
            }
            cout<<endl;
            beg+=i;
        }
    }
    return 0;
}
~~~

35.字符串加密

~~~cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string key,s;
    while(cin>>key>>s){
        string R;
        int p[26]={0};
        for(int i=0;i<key.length();i++){
            if(key[i]>='a'&&key[i]<='z'){
                if(p[key[i]-'a']==0){
                    R+=key[i]-32;
                    p[key[i]-'a']=1;
                }
            }else{
                if(p[key[i]-'A']==0){
                    R+=key[i];
                    p[key[i]-'A']=1;
                }
            }
        }
        for(int i=0;i<26;i++)
            if(p[i]==0)
                R+='A'+i;
        for(int i=0;i<s.length();i++)
            if(s[i]>='a'){
                char c=R[s[i]-'a']+32;
                cout<<c;
            }else{
                cout<<R[s[i]-'A'];
            }
            cout<<endl;
    }
    return 0;
}
~~~

36.统计每个月兔子的数量

此题描述不清

~~~cpp
#include<iostream>

using namespace std;
int getnum(int n){
     int count;
    if(n < 3)
      count =  1;
    else
      count= getnum(n-1)+getnum(n-2);
    return count;
}

int main(){
    int num;
   // int res ;
    while(cin >> num ){    
        cout<<getnum(num)<<endl;//没有endl就没办法进行相关的额解决思路
    }
    return 0;
}
~~~

37.求小球落地5次后所经历的路程和第5次反弹的高度

~~~cpp
#include<iostream>

using namespace std;

int main(){
    int data; //注意题目是输入的是一个整数  
   // int n = 4;
    while(cin>>data){
        int n = 5;
        double s = data;//总路程是指落地之前应该走的路程
        double h = data;//弹起的高度应该是弹起之后的高度
        while(n){
            h = h/2;
            s = s+2*h;
            n--;
        }
        cout << s - 2*h<<endl<< h <<endl;
        //cout << h/2 <<endl;
        
    }
    return 0;
}
~~~

38.判断两个IP是否属于同一子网

~~~cpp
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
 
using namespace std;
 
int main()
{
    int mask1 = 0, mask2 = 0, mask3 = 0, mask4 = 0;
    char ch;
    string inputstr;
    stringstream ss;
    while(cin>>inputstr)
    {
 
        int ip1a = 0, ip1b = 0, ip1c = 0, ip1d = 0;
        int ip2a = 0, ip2b = 0, ip2c = 0, ip2d = 0;
        ss<<inputstr;
        ss>>mask1>>ch>>mask2>>ch>>mask3>>ch>>mask4;
        ss.clear();
        cin>>inputstr;
        ss<<inputstr;
        ss>>ip1a>>ch>>ip1b>>ch>>ip1c>>ch>>ip1d;
        ss.clear();
        cin>>inputstr;
        ss<<inputstr;
        ss>>ip2a>>ch>>ip2b>>ch>>ip2c>>ch>>ip2d;
        ss.clear();
        if((mask1 > 255 || mask1 < 0) || (mask2 > 255 || mask2 < 0) || (mask3 > 255 || mask3 < 0) || (mask4 > 255 || mask4 < 0)
            || (ip1a > 255 || ip1a < 0) || (ip1b > 255 || ip1b < 0) || (ip1c > 255 || ip1c < 0) || (ip1d > 255 || ip1d < 0)
            || (ip2a > 255 || ip2a < 0) || (ip2b > 255 || ip2b < 0) || (ip2c > 255 || ip2c < 0) || (ip2d > 255 || ip2d < 0))
            cout<<1<<endl;
        else if(((mask1 & ip1a) == (mask1 & ip2a)) && ((mask2 & ip1b) == (mask2 & ip2b)) && ((mask3 & ip1c) == (mask3 & ip2c)) && ((mask4 & ip1d) == (mask4 & ip2d)))
            cout<<0<<endl;
        else
            cout<<2<<endl;
    }
    return 0;
}
~~~

39.输入一行字符，分别统计出包含英文字母、空格、数字和其他字符

~~~cpp
#include<iostream>
#include<string>
using namespace std;
int main()
    {
    string line;
    while(getline(cin,line))
        {
        int alpha = 0, space = 0, digit = 0,other = 0;
        for(auto i:line)
            if(isalpha(i))
                alpha++;
            else if (isdigit(i))
                digit++;
            else if(i==' ')
                space++;
            else
                other++;
        cout<<alpha<<endl<<space<<endl<<digit<<endl<<other<<endl;
    }
    return 0;
}
~~~

40.称砝码

~~~cpp

#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
int main()
{
     int n;//砝码数
     int m[10]={0};//每个砝码的质量
     int x[10]={0};//每个砝码的数量
     while(cin>>n){
        for(int i=0;i<n;i++)
            cin>>m[i];
        for(int i=0;i<n;i++)
            cin>>x[i];
        vector<int>weights; //存所有已经称出的砝码的质量。
        /*先将第一个砝码称出的质量入队。*/
        weights.push_back(0);//初始化weights数组
        for(int i=1;i<=x[0];i++)
            weights.push_back(i*m[0]);//将第一个砝码能称出的质量入队
        for(int i=1;i<n;i++){//前多少个砝码
            //weights.push_back(m[i]);
            int len=weights.size();//记录已经称出砝码质量便于下面for循环
            for(int j=1;j<=x[i];j++){//遍历该质量的砝码数
                for(int k=0;k<len;k++){
                int w=weights[k]+j*m[i];//将该质量的砝码数依次与前面所有的砝码数相加
                    //去重操作
                if(find(weights.begin(),weights.end(),w)==weights.end())//如果之前没有这个质量的砝码就将其入队
            weights.push_back(weights[k]+j*m[i]);
                }
            }
        }
        cout<<weights.size()<<endl;
     }
}
~~~

41.学英语(比较复杂)

~~~cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;
//forty fourteen呵呵 thirteen测试用例没用到，error情况也没用到，0也没测
vector<string> helper1{ "","thousand", "million", "billion" };
vector<string> helper2{ "", "", "twenty", "thirty", "forty","fifty","sixty","seventy","eighty","ninety" };
vector<string> helper3{ "", "one", "two", "three", "four","five","six","seven","eight","nine" };
vector<string> helper4{ "ten", "eleven", "twelve", "thirteen", "fourteen","fifteen","sixteen","seventeen","eighteen","nineteen" };
string sound(int num) {
    string res;
    if (num >= 0 && num <= 9) res += helper3[num];
    else if (num >= 10 && num <= 19) res += helper4[num % 10];
    else if (num >= 20 && num <= 99) {
        res += helper2[num / 10];
        if (num % 10 == 0) return res;
        res += " ";
        res += helper3[num % 10];
    }
    else {
        res += helper3[num / 100];
        res += "#hundred";
        num %= 100;
        if (num) {
            res += " and ";
            res += sound(num);
        }
    }
    return res;
}
int main() {
    long num;
    while (cin>>num) {
        vector<int> parts;
        string res;
        if (num == 0) {
            cout << "zero" << endl;
            continue;
        }
        else if(num > 999999999 || num < 0){
            cout << "error" << endl;
            continue;
        }
        while (num) {
            int tmp = num % 1000;
            parts.push_back(tmp);
            num /= 1000;
        }
        for (int i = parts.size() - 1; i >= 0; i--) {
            string tmp = sound(parts[i]);
            if (tmp == "") continue;
            res += tmp;
            if (i) {
                res += " ";
                res += helper1[i];
                res += " ";
            }
        }
        while (res[res.size() - 1] == ' ') res.erase(res.end() - 1);
        cout << res << endl;
    }
    return 0;
}
~~~

42.迷宫问题

~~~cpp

#include <iostream>
#include <queue>
#include <stack>
#include <utility>
#include <algorithm>
 
using namespace std;
 
int map[11][11];
pair<int, int> path[11][11];
int d[4][2] = { {-1, 0}, {0,-1}, {0, 1}, {1, 0} };
 
void bfs(int m, int n)
{
    queue<pair<int, int>> que;
    que.push({ 0, 0 });
    while (!que.empty())
    {
        pair<int, int> p = que.front();
        que.pop();
        if (p.first == m - 1 && p.second == n - 1) break;
        for (int i = 0; i < 4; ++i)
        {
            int x = p.first + d[i][0];
            int y = p.second + d[i][1];
            if (x >= 0 && x < m && y >= 0 && y < n && map[x][y] == 0)
            {
                que.push({ x, y });
                path[x][y] = { p.first, p.second };
                map[x][y] = 1;
            }
        }
    }
}
 
int main()
{
    int m, n;
    while (cin >> m >> n)
    {
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                cin >> map[i][j];
        bfs(m, n);
        stack<pair<int, int>> s;
        pair<int, int> p = path[m - 1][n - 1];
        s.push({ m - 1, n - 1 });
        s.push(p);
        while (true)
        {
            p = path[p.first][p.second];
            s.push(p);
            if (p.first == 0 && p.second == 0)
                break;
        }
        while (!s.empty())
        {
            pair<int, int> p = s.top();
            s.pop();
            cout << "(" << p.first << "," << p.second << ")" << endl;
        }
    }
}
 
    

~~~

43.数独（不会）

44.名字的漂亮度

~~~cpp
#include <iostream>
using namespace std;
 
int main()
{
    int test;
    while (cin >> test)
    {
        while (test--)
        {
            string st;
            cin >> st;
            int i, a[26] = {0}, k = 26, res = 0;
            for (i = 0; i < st.length(); ++i)
            {
                if (st[i] >= 'a' && st[i] <= 'z')
                    a[st[i] - 'a']++;
                else
                    a[st[i] - 'A']++;
            }
            sort(a, a + 26);
            for (i = 25; i >= 0; --i)
                res += a[i] * k--;
            cout << res << endl;
        }
    }
    return 0;
}

~~~

45.按字节截取字符串

~~~cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str;
    int num;
    while (cin >> str >> num)
    {
        cout << str.substr(0, num) << endl;
    }
    return 0;
}
//第二种方法
汉字占两个字节，每个字节的ASCII码最高位均为1，由于char默认为带符号类型，所以汉字的ASCII码小于0，而英文数字等其他字符占一个字节，ASCII码最高位为0，值在0~127之间。因此，只需要判断该字节是否小于0就能推断出是否为半个汉字。再向前推算有连续几个半个汉字，若有偶数个，则输出最后半个汉字，否则不输出

#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str;
    int num;
    while (cin >> str >> num)
    {
        int temp = num-1;
        while (temp >= 0 && str[temp] < 0)
            temp--;
        if ((num - temp) % 2 == 0)
            num--;
        cout << str.substr(0, num) << endl;
    }
    return 0;
}

~~~

46.线性插值(题意不明的傻逼题目)

47.单向链表中删除指定的节点

~~~cpp
//考察链表的插入和删除知识
#include <iostream>//题目上那个测试用例是错的，不要管那个
using namespace std;
struct ListNode{
    int key;
    ListNode *next;
    ListNode(int x):key(x),next(NULL){}
};
int main(){
    int n,key,pre;
    while(cin >> n >> key){
        ListNode *head = new ListNode(key);
        n--;
        while(n--){
            cin >> key >> pre;
            ListNode *p = head;
            while(p->key != pre) p = p->next;
            ListNode *curr = new ListNode(key);
            curr->next = p->next;
            p->next = curr;
        }
        cin >> key;
        ListNode *p = head;
        while(p){
            if(p->key != key) cout << p->key << " ";
            p = p->next;
        }
        cout << endl;
    }
    return 0;
}

~~~

48.多线程

~~~cpp
//想直接通过笔试
#include<iostream>
 
int main()
{
    int n;
    while(std::cin>>n)
    {
        for(int i =1;i<=n;++i)
            std::cout<<"ABCD";
        std::cout<<std::endl;
    }
    return 0;
}


~~~

~~~cpp
//更重要的是多线程代码的编写
#include<iostream>
#include<mutex>
#include<condition_variable>
#include<string>
#include<thread>
using namespace std;
string res("");
mutex mtx;
bool done = false;
condition_variable A, B, C, D;
void fun_A(int times) {
    while (times--) {
        unique_lock<mutex> locker(mtx);
        A.wait(locker);
        res += 'A';
        B.notify_one();
    }
    done = true;
}
void fun_B() {
    while (!done) {
        unique_lock<mutex> locker(mtx);
        B.wait(locker);
        res += 'B';
        C.notify_one();
    }
}
void fun_C() {
    while (!done) {
        unique_lock<mutex> locker(mtx);
        C.wait(locker);
        res += 'C';
        D.notify_one();
    }
}
void fun_D() {
    while (!done) {
        unique_lock<mutex> locker(mtx);
        D.wait(locker);
        res += 'D';
        A.notify_one();
    }
}
int main() {
    int num;
    while (cin >> num) {
        res = "";
        thread t1(fun_A, num);
        thread t2(fun_B);
        thread t3(fun_C);
        thread t4(fun_D);
        A.notify_one();
        t1.join();
        t2.join();
        t3.join();
        t4.join();
        cout << res << endl;
        done = false;
    }
    return 0;
}
~~~

49.四则运算

两个栈？

~~~cpp
#include <iostream>
#include <string>
#include <stack>
#include <sstream>
#include <map>
 
using namespace std;
stack<char> sig;
stack<int> nums;
map<char,char> dict= {{']','['},{')','('},{'}','{'}};
int core(int num1,int num2,char c)
{
    if(c=='+')
        return num1+num2;
    if(c=='-')
        return num2-num1;
    if(c=='*')
        return num1*num2;
 
    return num1/num2;
}
void calc()
{
     int num1=nums.top();
     nums.pop();
     int num2=nums.top();
     nums.pop();
     nums.push(core(num1,num2,sig.top()));
     sig.pop();
}
int main()
{
    string s;
    while(cin>>s)
    {
 
        int l=s.length();
        stringstream ss;
        int tp;
        for(int i=0;i<l;i++)
        {
            if(s[i]>='0'&&s[i]<='9')
            {
                int j=i;
                while(j<l&&s[j]>='0'&&s[j]<='9')
                    j++;
                ss<<s.substr(i,j-i);
                ss>>tp;
                nums.push(tp);
                ss.clear();
                i=--j;
                continue;
            }
            else if(s[i]=='+'||s[i]=='-')
            {
                while(!sig.empty()&&(sig.top()=='/'||sig.top()=='*'||sig.top()=='+'||sig.top()=='-'))
                    calc();              
            }
            else if(s[i]=='/'||s[i]=='*')           
            {
                 while(!sig.empty()&&(sig.top()=='/'||sig.top()=='*'))
                    calc();               
            }
 
            else if(dict.count(s[i]))
            {              
                char c=dict[s[i]];
                while(!sig.empty()&&sig.top()!=c)
                    calc();
                sig.pop();
                continue;
            }
             sig.push(s[i]);
        }
        while(!sig.empty())
            calc();
        cout<<nums.top()<<endl;
        nums.pop();
    }
}
~~~

50.输出单向链表的倒数第k个节点

~~~cpp
//思路：采用头插法，倒数第k个转变为求正数第k个
#include<iostream>
using namespace std;
typedef struct Node
{
    int data;
    Node *next;
}*pNode;
void creatList(pNode &head,int n)
{
    pNode p=head;
    pNode s=NULL;
    int data;
    for(int i=0;i<n;++i)
    {
        cin>>data;
        s=(pNode)malloc(sizeof(Node));
        s->data=data;
        s->next=p;
        p=s;
    }
    head=p;
}
void printList(pNode head,int k)
{
    if(head==NULL)
        return ;
    pNode p=head;
    if(k<1)
    {
        cout<<0<<endl;
        return ;
    }
    for(int i=0;i<k-1;++i)
        p=p->next;
    cout<<p->data<<endl;
}
int main()
{
    int n;
    while(cin>>n)
    {
       int k=0;
       pNode head=NULL;
       creatList(head,n);
       cin>>k;
       printList(head,k);
    }
    return 0;
}
~~~

51.计算字符串的距离

~~~cpp
//典型的动态规划优化编辑器问题
//参考博客 http://blog.csdn.net/shizheng163/article/details/50988023
#include<iostream>
#include <string>
#include <vector>
using namespace std;
int calStringDistance(string a,string b){
    int n = (int)a.size(),m = (int)b.size();
    vector<vector<int>>dp(n+1,vector<int>(m+1,0));
    dp[0][0] = 0;//dp[x][y]代表将a字符串前x个字符修改成b字符串前y个字符
    for (int i=1; i<=m; ++i) dp[0][i] = i;
    for (int i=1; i<=n; ++i) dp[i][0] = i;
    for (int i=1; i<=n; ++i) {
        for (int j=1; j<=m; ++j) {
            int one = dp[i-1][j] +1,two = dp[i][j-1]+1,three = dp[i-1][j-1];
            if(a[i-1]!=b[j-1]) three+=1;
            dp[i][j] = min(min(one,two),three);
        }
    }
    return dp[n][m];
}
int main(){
    string a,b;
    while(cin>>a>>b)
        cout<<calStringDistance(a, b)<<endl;
    return 0;
}
~~~

52.杨辉三角的变形

53.表达式求值

54.挑7

~~~cpp
#include<iostream>
#include<vector>

using namespace std;

int main(){
    int a;
    while(cin >> a){
        int count = 0;
        for(int i = 7; i <= a; i++){
            if( i%7 == 0)
                count++;
            string s = to_string(i) ;
            if(s.find('7')!=s.npos&&i%7 != 0)
                count++;
        }
        cout << count<<endl;
    }

    return 0;
}
~~~

55.完全计算数

~~~cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    while(cin >> n){
        if(n > 0 && n <= 500000){
            int counts = 0;
            for(int i = 1; i <= n; ++i){
                int sum = 0;
                for(int j = 1; j <= i/2; ++j)
                    if(i % j == 0)
                        sum += j;
                if(i == sum)
                    counts++;
            }
            cout << counts << endl;
        }
        else
            cout << "-1" << endl;
    }
    return 0;
}
//自己做的
#include<iostream>
#include<vector>
#include<math.h>

using namespace std;

bool isPefect(int a )
{
    vector<int> vec;
    int sum = 0;
    for(int i = 1; i <= a/2; i++){
        if( a%i == 0)
            vec.push_back(i);
    }
    for(int i = 0 ; i < vec.size(); i++)
        sum = sum + vec[i];
    if( sum == a)
        return true;
    else
        return false;
}

int main(){
    int a;
    while(cin >> a){
        int count = 0;
        while(a>1){
            if( isPefect(a))
                count++;
            a--;
        }
      
            cout<<count<<endl;
    }
    return 0;
}
~~~

56.高精度整数加法

~~~cpp
//C++真是曹乐

//本算法支持正正，负负和一正一负四种情况。
//负负时，去掉两个前导符，然后转化为加法；
//一正一负时，先比较操作数大小，然后做减法
#include <string>
#include <iostream>
using namespace std;
string add(string s1,string s2);
string sub(string s1,string s2);
int main()
{
    string s1;string s2;
    while(cin>>s1>>s2)
    {
 
        if(isdigit(s1[0])&&isdigit(s2[0]))
            cout<<add(s1,s2)<<endl;
        else if(!isdigit(s1[0])&&!isdigit(s2[0]))
        {
            s1=s1.substr(1);s2=s2.substr(1);
            cout<<'-'+add(s1,s2)<<endl;
        }
        else if(isdigit(s1[0])&&!isdigit(s2[0]))//一正一负时先去掉前导-，然后补齐再比较操作数的大小
        {
            s2=s2.substr(1);
            if(s1.size()>s2.size()) s2=string(s1.size()-s2.size(),'0')+s2;//去掉前导后补齐两个字符串
            else    s1=string(s2.size()-s1.size(),'0')+s1;//由于要判断s1，s2的大小，所以要先补齐再判断
            if(s1>s2)   cout<<sub(s1,s2)<<endl;//如123,-57,去掉前导-然后调用减法函数
            else    cout<<'-'+sub(s2,s1)<<endl;//如23,-157,去掉前导-,交换位置后调用减法函数再加上前导-
        }
        else
        {
            s1=s1.substr(1);
            if(s1.size()>s2.size()) s2=string(s1.size()-s2.size(),'0')+s2;
            else    s1=string(s2.size()-s1.size(),'0')+s1;//去掉前导后补齐两个字符串
            if(s1>s2)   cout<<'-'+sub(s1,s2)<<endl;//如-123,57
            else    cout<<sub(s2,s1)<<endl;//如-23,157
        }
    }
}
 
string add(string s1,string s2)//字符串加法
{
    string res="";
    if(s1.size()>s2.size()) s2=string(s1.size()-s2.size(),'0')+s2;
    else    s1=string(s2.size()-s1.size(),'0')+s1;//去掉前导后补齐两个字符串
    int carry=0;
    for(int i=s1.size()-1;i>=0;i--)
    {
        char temp=(s1[i]-'0'+s2[i]-'0'+carry)%10+'0';
        res=temp+res;
        carry=(s1[i]-'0'+s2[i]-'0'+carry)/10;
    }
    if(carry)   res='1'+res;
    return res;
}
 
string sub(string s1,string s2)//减法，主函数处理后保证结果是正数
{
    string res="";
    int borrow=0;int i=s1.size()-1;
    for(;i>=0;i--)
    {
        int op1=(s1[i]-borrow>=s2[i])?(s1[i]-borrow-'0'):(10+s1[i]-borrow-'0');
        int op2=s2[i]-'0';
        char temp=op1-op2+'0';
        res=temp+res;
        borrow=s1[i]-borrow<s2[i];
    }
    while(res[++i]=='0');//去掉前导0
    res=res.substr(i);
    return res;
}

~~~

57.输入n个整数，输出其中最小的k个；

~~~cpp
//代码提交了几次，都是错误的，原因是格式错误。
//在输出结果的时候，先输出前k-1个，cout<<arr[i]<<" ";
//最后输出最后一个数字不带空格就行。cout<<arr[k];
//c++代码如下：
#include<iostream>
#include <algorithm>
using namespace std;
 
void Print_k_Of_arr(int* arr,int num,int k_Number)
{
    if(k_Number>num)
    {
        return ;
    }
    else
    {
        sort(arr,arr+num);
        for(int i=0;i<k_Number-1;i++)
        {
            cout<<arr[i]<<" ";
        }
        cout<<arr[k_Number-1];
    }  
}
int main()
{
    int num=0,k=0;
    int arr[1000]={0};
    while(scanf("%d %d",&num,&k)!=EOF)
    {
        for(int i=0;i<num;i++)
        {
            cin>>arr[i];
        }
        Print_k_Of_arr(arr,num,k);
    }
    return 0;
}
//方法2：采用最大堆。
//（注意这个题目的测试用例答案要升序输出，所以这个题目出的不好） #include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
using namespace std;
 
void Heap_K_Number(vector<int>& temp,int N,int k)
{
    if(k>N) return;
    //将前K个元素（下标为0~k-1）导入vector容器中，下面要制作堆
    vector<int> heap(temp.begin(),temp.begin()+k);
    //初始化最大堆
    make_heap(heap.begin(),heap.end());
     
    //从K+1个元素（下标就是k~N-1）
    for(int i=k;i<N;i++)
    {
        if(temp[i]<heap[0])//比堆顶元素小 ，调整堆
        {
            pop_heap(heap.begin(),heap.end());
            heap.pop_back();
             
            heap.push_back(temp[i]);
            push_heap(heap.begin(),heap.end());
        }
    }
     
    //输出堆
    for(int i=0;i<k-1;i++)
        cout<<heap[i]<<" ";
    cout<<heap[k-1];
}
 
int main()
{
    int n,k,temp;
    vector<int> vec;
    while(cin>>n>>k)
    {
        for(int i=0;i<n;i++)
        {
            cin>>temp;
            vec.push_back(temp);
        }
        Heap_K_Number(vec,n,k);
    }
}
~~~

58.找出字符串中第一个只出现一次的字符

~~~cpp
#include<iostream>
#include<string>
#include<vector>
#include<map>

using namespace std;

int main()
{
    string str;
    while(cin>>str){
    map<char,int>mymap;
    for(int i = 0; i < str.size(); i++)
        mymap[str[i]]++;
     bool flag = false;
    for(int i = 0; i < str.size(); i++){
        if(mymap[str[i]] ==1)
        {  
            cout << str[i]<<endl;//不加endl通过不了
           flag = true;
            break;
       }
    }
     if(flag==false)//如果没有找到
            cout<<"-1"<<endl;
    }

    return 0;
}
~~~

59.查找组成一个偶数最接近的两个素数

~~~cpp
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;
 
bool isPrime(int i)
{
    for (int j = 2; j <= sqrt(i * 1.0); j++) {
        if (i % j == 0)
            return false;
    }
    return true;
}
 
int main() {
    int n;
    int Prime1, Prime2;
    while (cin >> n) {
        if (n < 2)
            return 1;
        else {
            for (int i = 1; i <= n / 2;i++) {
                if (isPrime(i) && isPrime(n - i)) {
                    Prime1 = i;
                    Prime2 = n - i;
                }
            }
            cout << Prime1 << endl;
            cout << Prime2 << endl;
            }
    }
    return 0;
}
//自己做的为什么通不过所有案例
#include<math.h>
#include<iostream>
using namespace std;

bool isnum(int a){
    if( a == 1)
        return false;
    if(a == 2)
        return true;
    for(int i = 2;i <= sqrt(a);i++)//一定要等于
    {
        if(a%i == 0)
        return false;}
    return true;
}

int main(){
    int num;
    while(cin >> num){
        int med = num/2;

            for(int i =0; i <= med; i++)
                if(isnum(med-i)&&isnum(med+i))
                {
                    cout << med-i<<endl;
                    cout << med+i<<endl;
                    break;
                }
    }
    
    return 0;
}

~~~

60.放苹果

~~~cpp
#include <iostream>
 
using namespace std;
 
/*  解题分析：
        设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，
        当n>m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n>m) f(m,n) = f(m,m)　　
        当n<=m：不同的放法可以分成两类：
        1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1); 
        2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n).
        而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n)
    递归出口条件说明：
        当n=1时，所有苹果都必须放在一个盘子里，所以返回１；
        当没有苹果可放时，定义为１种放法；
        递归的两条路，第一条n会逐渐减少，终会到达出口n==1;
        第二条m会逐渐减少，因为n>m时，我们会return f(m,m)　所以终会到达出口m==0．
*/
 
int func(int m,int n)  //m个苹果放在n个盘子敏感词有几种方法
{
    if(m==0||n==1)  //因为我们总是让m>=n来求解的，所以m-n>=0,所以让m=0时候结束，如果改为m=1，
        return 1;    //则可能出现m-n=0的情况从而不能得到正确解   
    if(n>m)
        return func(m,m);
    else
        return func(m,n-1)+func(m-n,n);
}
 
int main(){
    int m, n;
    while (cin >> m >> n){
        if (m < 0 || m > 10 || n < 0 || n > 10) continue;
        cout << func(m, n) << endl;
    }
    return 0;
}
//动态规划的思想
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
 
int main() {
    int M, N;
    while (cin >> M >> N) {
        if (M < 1 || M>10 || N < 1 || N>10) {
            cout << -1 << endl;
            continue;
        }
        vector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));
        for (int i = 1; i <= N; i++) dp[0][i] = 1;
        for (int i = 1; i <= M; i++)
            for (int j = 1; j <= N; j++)
                dp[i][j] = dp[i][j - 1] + (i < j ? 0 : dp[i - j][j]);
        cout << dp[M][N] << endl;
    }
}

~~~

61.查找输入整数二进制中1的个数

~~~cpp
#include<iostream>
 
using namespace std;
 
int main()
{
    int n;
    while(cin >> n)
    {
        int count = 0;
        while(n > 0)
        {
            if(n & 1) ++count;
            n >>= 1;
        }
 
        cout << count << endl;
    }
     
    return 0;
}
~~~

62.DNA序列

~~~cpp
#include<iostream>
using namespace std;
int main(){
    string str;
    int len;
    while(cin >> str >> len){
        int index = 0, max = 0;
        for(int i = 0; i <= str.size()-len; ++i){
            int counts = 0;
            for(int j = i; j < i+len; ++j){
                if(str[j] == 'G' || str[j] == 'C')
                    counts ++;
            }
            if(counts > max){
                max = counts;
                index = i;
            }
        }
        cout << str.substr(index, len) << endl;
    }
    return 0;
}

~~~

63.mp3光标的位置

~~~cpp

~~~

64.查找两个字符串a,b中的最长公共字串

~~~cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string a, b;
    while (cin >> a >> b)
    {
        if (a.size() > b.size())
            swap(a, b);
        string str_m;//存储最长公共子串
        for (int i = 0; i < a.size(); i++)
        {
            for (int j = i; j < a.size(); j++)
            {
                string temp = a.substr(i, j - i + 1);
                    if (int(b.find(temp))<0)// string::npos(代表 -1 表示不存在)
                    break;
                else if (str_m.size() < temp.size())
                    str_m = temp;
            }
        }
        cout << str_m << endl;
    }
    return 0;
}



//思路：动态规划经典问题，加一个start标记即可,注意将较短子串最先出现的那个输出
#include<iostream>
#include<vector>
#include<string>
using namespace std;
void findMaxCommonStr(string s1,string s2)
{
    if(s1.length()>s2.length())
            swap(s1,s2);//s1用于保存较短的子串
    int len1=s1.length(),len2=s2.length();
    int maxLen=0,start=0;
    vector<vector<int> >dp(len1+1,vector<int>(len2+1,0));
    for(int i=1;i<=len1;++i)
        for(int j=1;j<=len2;++j)
        {
            if(s1[i-1]==s2[j-1])
            {
                dp[i][j]=dp[i-1][j-1]+1;
                if(dp[i][j]>maxLen)
                {
                    maxLen=dp[i][j];
                    start=i-maxLen;//记录最长公共子串的起始位置
                }
            }
        }
   cout<<s1.substr(start,maxLen)<<endl;
}
int main()
{
   string s1,s2;
   while(cin>>s1>>s2)
   {
       findMaxCommonStr(s1,s2);
   }
   return 0;
}

~~~

65.配置文件恢复

~~~cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
bool match(string str, string s) {
    return str.find(s) == 0;
}
int main() {
    string str;
    string cmd[6] = {"reset",       "reset board", "board add",     "board delet",      "reboot backplane", "backplane abort" };
    string res[7] = {"reset what",  "board fault", "where to add",  "no board at all",  "impossible",       "install first",    "unkown command" };
    while (getline(cin, str)) {
        string s1, s2, temp;
        stringstream ss(str);
        ss >> s1 >> s2;
        int resi = 6;
        if (s2.empty())
            resi = match(cmd[0], s1) ? 0 : 6;
        else {
            bool flag = false;
            for (int i = 1; i < 6; i++) {
                stringstream allcmd(cmd[i]);
                allcmd >> temp >> temp;
                if (match(cmd[i], s1) && match(temp, s2)) {
                    if (!flag) {
                        flag = true;
                        resi = i;
                    } else {
                        resi = 6;
                        break;
                    }
                }
            }          
        }
        cout << res[resi] << endl;
    }
    return 0;
}//大家的都好长，我来个短一点的吧。。。。
~~~

66.24点游戏算法

~~~cpp
//搞了半天原来是可以有括号的，全排列+递归就可以了，而全排列本身又可以递归来做。
//不要忘记恢复现场就行。
#include<iostream>
using namespace std;
 
inline void Swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
 
bool is24(int a[], int begin, int end, double tot)
{
    if (begin==end-1) return (a[begin] == tot);
    else
    {
        bool ans = false;
        for (int i = begin; i<end; i++)
        {
            swap(a[i], a[end-1]);
            ans = ans || is24(a, begin, end - 1, tot + a[end - 1]) || is24(a, begin, end - 1, tot - a[end - 1]) || is24(a, begin, end - 1, tot * a[end - 1]) || is24(a, begin, end - 1, tot / a[end - 1]);
            swap(a[i], a[end-1]);
        }
        return ans;
    }
 
 
}
 
int main()
{
    int a[4];
    while (cin >> a[0] >> a[1] >> a[2]>>a[3])
    {
        if (is24(a, 0,4, 24)) cout << "true" << endl;
        else cout << "false" << endl;
    }
}
~~~

67.成绩排序

~~~cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;
struct student{
  string name;
    int score;
};
bool cmp0(const student &a, const student &b){
    // 从高到低排序
    return a.score > b.score;
}
bool cmp1(const student &a, const student &b){
    // 从低到高排序
    return a.score < b.score;
}
int main(){
    //freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
    int N, type;
    while(cin >> N >> type){
        vector<student> stud(N);
         
        for(int i = 0; i < N; i ++){
            cin >> stud[i].name >> stud[i].score;
        }
        if(type == 0)
            stable_sort(stud.begin(), stud.end(), cmp0);
        else
            stable_sort(stud.begin(), stud.end(), cmp1);
         
        for(int i = 0; i < N; i ++){
            cout << stud[i].name << " " << stud[i].score << endl;
        }
    }
     
    return 0;
}
~~~

68.矩阵相乘

~~~cpp
#include<iostream>
#include<vector>
using namespace std;
int main(){
    int x, y, z;
    while (cin >> x >> y >> z){
        vector<vector<int>> arr1(x, vector<int>(y, 0));
        vector<vector<int>> arr2(y, vector<int>(z, 0));
        vector<vector<int>> arr3(x, vector<int>(z, 0));
        for(int i = 0; i < x; ++i){
            for(int j = 0; j < y; ++j)
                cin >> arr1[i][j];
        }
        for(int i = 0; i < y; ++i){
            for(int j = 0; j < z; ++j)
                cin >> arr2[i][j];
        }
        for(int i = 0; i < x; ++i){
            for(int j = 0; j < y; ++j)
                for(int k = 0; k < z; ++k)
                    arr3[i][k] += arr1[i][j] * arr2[j][k];
        }
        for(int i = 0; i < x; ++i){
            for(int j = 0; j < z-1; ++j)
                cout << arr3[i][j] << " ";
            cout << arr3[i][z-1] << endl;
        }
    }
    return 0;
}
~~~

69.矩阵乘法计算量估算

~~~cpp

~~~

70.字符串通配符

71.百钱买百鸡

~~~cpp
//鸡翁、鸡母、鸡雏分别为x, y, z 三个变量。
//x+y+z=100
//5x+3y+z/3=100
//确定x即可算出y和z，若y和z为非负整数，则为有效结果，输出。
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    int n;
    while (cin >> n)
    {
        for (int x = 0; x <= 100/5; x++)
        {
            double y = (200 - 14 * x) / 8.0;
            double z = 100 - y - x;
            if (y == int(y) && y >= 0 && z >= 0)
                cout << x << " " << y << " " << z << endl;
        }
    }
    return 0;
}
~~~

72.计算日期到天数的转换

~~~cpp
#include<iostream>
using namespace std;
int dataToDay(int year,int month,int day)
{
    if(year<=0||month<=0||month>12||day>31||day<=0) return -1;
    int lemp[12]={31,29,31,30,31,30,31,31,30,31,30,31};
    int Nolemp[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag;
    if((year%4==0&&year%100!=0)||(year%400==0))
       flag = true;
    else
       flag = false;
    if(flag)
     {
        if(day>lemp[month-1]) return -1;
    }
    else
        {
        if(day>Nolemp[month-1]) return -1;
    }
    int temp=0;
    for(int i=0;i<month-1;i++)
        {
            if(flag)
               temp=temp+lemp[i];
            else
               temp=temp+Nolemp[i];
        }
    return temp+day;
}
 
int main()
{
    int year,month,day;
    while(cin>>year>>month>>day)
    {
       cout<<dataToDay(year,month,day)<<endl;
    }
     
}

~~~

73.参数解析

74.公共字符串计算（求最长公共字符串的长度）

75.尼科切四定律

找规律即可

76.火车进站（这个题的意图就是考下列哪个序列不可能是123出栈序列）

~~~cpp
#include<iostream>
#include<stack>
#include<algorithm>
using namespace std;
bool isOutNum(int *push,int *pop,int len)//判断pop是不是push的出栈序列
{
    if(push==NULL || pop==NULL ||len<=0)
        return false;
    stack<int> Stack;
    int i=0,j=0;
    for(i=0;i<len;i++)//依次把push中的数入栈
    {
        Stack.push(push[i]);
        while(j<len && Stack.size()!=0 && pop[j]==Stack.top())//依次判断pop序列每个值是否与栈顶相等
        {
            Stack.pop();
            j++;
        }
    }
    return Stack.empty();
}
int main()
{
    int N;
    while(cin>>N)
    {
        int *pushNum=new int [N];
        int *popNum=new int [N];
        for(int i=0;i<N;i++)
        {
            cin>>pushNum[i];
            popNum[i]=pushNum[i];
        }
        sort(popNum,popNum+N);
        do
        {
            if(isOutNum(pushNum,popNum,N))//如果该排列正确，则输出
            {
                for(int i=0;i<N-1;i++)
                    cout<<popNum[i]<<" ";
                cout<<popNum[N-1]<<endl;
            }
        }
        while(next_permutation(popNum,popNum+N));//获取下一个排列       
    }
    return 0;
}
~~~



77.超长正整数相加

~~~cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string a, b;
    while (cin >> a >> b)
    {
        int temp = 0, carry = 0;
        while (a.size()<b.size())
            a = "0" + a;
        while (a.size()>b.size())
            b = "0" + b;
        for (int i = a.size() - 1; i >= 0; i--)
        {
 
            temp = a[i] - '0' + b[i] - '0' + carry;
            a[i] = temp%10 + '0';
            if (temp / 10)
                carry = 1;
            else
                carry = 0;
        }
        if (carry)
            a = "1" + a;
        cout << a << endl;
    }
    return 0;
}
~~~

78.计算字符串的相似度

~~~cpp
这道题其实简单的理解就是为了求字符串的最小编辑代价，也是一个经典的动态规划题，复杂度O(M*N)
思路：1.求解状态转移矩阵dp[M + 1][N + 1],dp[i][j] 的值代表的是str1[0...i-1]编辑为str2[0...j-1]
的最小代价。
2. 计算过程：
1）dp[0][0] = 0,表示str1空的字串编辑为str2空的字串代价为0。
2）矩阵dp第一列即为dp[0...M-1][0],dp[i][0] 表示str1[0...i-1]编辑为空串的最小代价，所以就是将str1[0..M-1]的字符删掉的代价
所以dp[i][0] = i;
3) 同2），那str2[0...j-1]编辑的代价，dp[0][j] = j;
4) 接下来的位置就按照从左到右，从上到下来计算，dp[i][j]的值来至于下面的几种情况：
（1）str1[0...i-1]可以先编辑为str1[0..i-2],也就是删除字符str1[i-1],然后由str1[0..i-2]编辑为str2[0...j-1]，dp[i-1][j]表示str1[0..i-2]编辑为str2[0...j-1]的最小代价，
那么dp[i][j]可能等于dp[i -1][j] + 1;
(2）str1[0...i-1]可以先编辑为str1[0..i-2],然后将str2[0..j-2]插入字符str2[j-1],编辑成str2[0...j-1]，dp[i][j-1]表示str1[0..i-1]编辑成str2[0...j-2]的最小代价，
那么dp[i][j] 可能等于dp[i][j-1] + 1;
(3) 如果str1[i - 1]!=str2[j-1] ，那么先把str1[0..i-1]中的str1[0..i-2]的部分边长str2[0..j-2]，然后把字符str1[i-1]替换为str2[j-1],这样str1[0..i-1]就编辑成为str2[0...j-1]了，dp[i - 1][j - 1]表示
str1[0..i-2]编辑为str2[0..j-2]的最小代价，那么dp[i ][j]可能等于dp[i - 1][j - 1] + 1;
(4) 如果str1[i - 1]==str2[j-1] ，那么先把str1[0..i-1]中的str1[0..i-2]的部分边长str2[0..j-2]，因为此时   str1[i - 1]==str2[j-1] ，所以str1[0..i-1]已经编辑为str2[0..j-1]了，dp[i - 1][j - 1]表示str1[0..i-2]编辑为str2[0..j-2]的最小代价， 那么dp[i ][j]可能等于dp[i - 1][j - 1]。
 
上述的4中情况取最小值,dp的最右下角就是最终结果，即最小编辑代价。


#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
int main() {
    string s1, s2;
    while (cin >> s1 >> s2) {
        string res = "1/";
        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));
        for (int i = 1; i <= s2.length(); i++) dp[0][i] = i;
        for (int i = 1; i <= s1.length(); i++) dp[i][0] = i;
        for (int i = 1; i <= s1.length(); i++)
            for (int j = 1; j <= s2.length(); j++) {
                int min1 = min(dp[i - 1][j], dp[i][j - 1]) + 1;
                dp[i][j] = min((s1[i - 1] == s2[j - 1] ? 0 : 1) + dp[i - 1][j - 1], min1);
            }
        res += to_string(1 + dp[s1.size()][s2.size()]);
        cout << res << endl;
    }
}
~~~

79.整型数组合并

就是归并算法

80.字符串匹配

短字符串所有的字符是否在长字符串中全部出现

~~~cpp
//思路：判断s1中的每个字符是否都在s2中
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main(){
    string s1,s2;
    while(cin>>s1>>s2){
        bool flag=true;
        for(int i=0; i<s1.size(); i++){
            if(s2.find(s1[i])==-1){
                cout<<"false"<<endl;
                flag=false;
                break;
            }         
        }
        if(flag)
        cout<<"true"<<endl;
    }
    return 0;
}

~~~

81.将真分数分解为埃及分数

~~~cpp
#include<iostream>
#include<string>
using namespace std;
int main(){
    char ch;
    int a, b;
    while (cin >> a >> ch >> b)
    {
        while (a != 1){
            if (b % (a - 1) == 0){
                cout << 1 << "/" << b / (a - 1) << "+";
                a = 1;
            }
            else{
                int c;
                c = b / a + 1;
                a = a - b%a;
                b = b*c;
                cout << 1 << "/" << c << "+";
                if (b%a == 0){
                    b = b / a;
                    a = 1;
                }
            }
        }
        cout << 1 << "/" << b << endl;
    }
    return 0;
}

~~~

82.二维数组操作

题目在说啥，扎心

83.统计大写字母的个数、

84.字符串应用，密码截取

~~~cpp
//本题等价于求最长公共字串
#include<string>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
 
int main(){
    string s;
    while(cin>>s){
        string t(s);
        reverse(t.begin(),t.end());
        int len = t.size();
        vector<int> ans(len+1,0);
        vector<vector<int> > dp(len+1,ans);
        int maxLen=0;
        for(int i=1;i<=len;i++){
            for(int j=1;j<=len;j++){
                if(s[i-1]==t[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;  
                }
                if(dp[i][j]>maxLen)maxLen = dp[i][j];
            }
        }
        cout<<maxLen<<endl;
    }
    return 0;
}
~~~

85.求最大连续bit数

~~~cpp
#include<iostream>
using namespace std;
int main()
{
    int byte;
    while(cin>>byte)
    {
        int k=0;
        for( k=0;byte!=0;k++)
        {
            byte=byte&(byte<<1);
        }
        cout<<k<<endl;
    }
    return 0;
}
~~~

86.密码强度等级

87.扑克牌大小

88.24点运算

89.合法的IP

90.JAVA题目2~3级

~~~cpp
用递归来做，将右下角看做原点(0, 0)，左上角看做坐标(m, n)，下图所示：

从(m, n)—>(0, 0)就分两步走：
往右走一步：f(m, n - 1)—>(0, 0) 加上下走一步：f(m - 1, n)—>(0, 0)
注意：但凡是触碰到边界，也就是说f(x, 0)或者f(0,x)都只有一条直路可走了，这里的x是变量哈。
f(m, n) = f(m, n - 1) + f(m - 1, n)
#include <iostream>
 
using namespace std;
 
int func(int m, int n) {
    if (m == 0 || n == 0) {
        return 1;
    }
    return func(m, n - 1) + func(m - 1, n);
}
int main() {
    int m, n;
    while (cin >> m >> n) {
        cout << func(m, n) << endl;
    }
 
    return 0;
}
//动态规划
#include <iostream>
#include <vector>
 
using namespace std;
 
int main() {
    int m, n;
    while (cin >> m >> n) {
        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 0));
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = 1;
                    continue;
                }
                if (i == 0) {    // 上边界
                    dp[i][j] = dp[i][j - 1];
                } else if (j == 0) {    // 左边界
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        cout << dp[n][m] << endl;
    }
 
    return 0;
}
~~~

91.字符串中找到连续最长的数字串

~~~cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{  
    string str;
    while( cin>>str )
    {
        int i;
        int max = 0;
        string ss;
        string out;
        for(i = 0; i < str.size(); i++)
        {
            if(str[i] >= '0' &&str[i] <= '9')
            {
                ss += str[i];
                while(str[i+1] >= '0' &&str[i+1] <= '9')
                {
                    i++;
                    ss += str[i];
                }
                if(ss.size() > max)
                {
                    max = ss.size();
                    out = ss;                  
                }
                else if(ss.size() == max)
                    out += ss;
            }
            ss.clear();           
        }
        cout<<out<<','<<max<<endl;       
    }
    return 0;
}
~~~

92.java0-1级

~~~cpp
/*
思路：参考：ld1230
1.接收数据，分别计算被5整出，被3整出的总和，以及将剩下数据保存起来
2.判断是否有可能存在解，如果没有，直接输出false
3.若可能的话，将问题转化成，利用剩下的数据进行加减运算，得到一个数，这个数的绝对值和sum5-sum3的绝对值相同
即为true，用递归的方式进行求解。
*/
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
bool judge(int i,int n,vector<int>& irest,int sum1,int sum2)
{
    if(i==n)//当所有元素都分配完成时
        return abs(sum1)==abs(sum2);//判断是否存在一个解
    return judge(i+1,n,irest,sum1+irest[i],sum2) || judge(i+1,n,irest,sum1-irest[i],sum2);//递归
}
int main()
{
    int n;
    while(cin>>n)
    {
        int sum=0,sum5=0,sum3=0,sumRest=0;
        int temp;
        vector<int>irest;
        bool flag=false;//用于判断是否存在解
        for(int i=0;i<n;++i)
        {
            cin>>temp;
            sum+=temp;
            if(temp%5==0)
                sum5+=temp;
            else if(temp%3==0)
                sum3+=temp;
            else
                irest.push_back(temp);
        }
        if(sum%2!=0)//如果和不为偶数，则不可能存在解
            cout<<"false"<<endl;
        else
        {
            sum=abs(sum5-sum3);
            flag=judge(0,irest.size(),irest,0,sum);//判断是否有解
            if(flag)
                cout<<"true"<<endl;
            else
                cout<<"false"<<endl;
        }
         
    }
    return 0;
}
~~~

93.计票统计

~~~cpp
//vector和map结合存储，用map查找投票是否合法
#include <iostream>
#include <string>
#include <vector>
#include <map>
using namespace std;
int main(){
    int m,n;
    while(cin>>m){
        map<string,int> M;
        vector<string> vec(m);
        string s;
        for(int i=0;i<m&&cin>>s;i++){
            M[s]=0;
            vec[i]=s;
        }
        cin>>n;
        for(int i=0;i<n&&cin>>s;i++)
            if(M.find(s)!=M.end())
                M[s]++;
        int count=0;
        for(auto it=vec.begin();it!=vec.end();it++){
            cout<<*it<<" : "<<M[*it]<<endl;
            count+=M[*it];
        }
        cout<<"Invalid : "<<n-count<<endl;
    }
    return 0;
}
~~~

94.人民币转换

~~~cpp
#include <iostream>
using namespace std;
 
char *m_money[11] = {"零","壹","贰","叁","肆","伍","陆","柒","捌","玖","拾"};
 
void printQBS(int num){
    int qian;
    int bai;
    int shi;
    int ge;
    qian = num/1000;
    num -= qian*1000;
    bai = num/100;
    num -= bai*100;
    shi = num/10;
    num -= shi*10;
    ge = num;
 
    if(qian != 0)
        cout<<m_money[qian]<<"仟";
    if(bai != 0){
        cout<<m_money[bai]<<"佰";
    }
    if(qian != 0 && bai == 0){
        cout<<m_money[bai];
    }
    if(shi != 0){
        if(shi != 1)
            cout<<m_money[shi]<<"拾";
        else
            cout<<"拾";
    }
    if(bai != 0 && shi == 0){
        cout<<m_money[shi];
    }
    if(ge != 0){
        cout<<m_money[ge];
    }
}
 
int main(){
    double money;
    while(cin>>money){
        money += 0.005;
        cout<<"人民币";
        int num;
        //1、计算亿
        num = money/100000000;
        money -= num*100000000;
        if(num != 0){
            printQBS(num);
            cout<<"亿";
        }
        //2、计算万
        num = money/10000;
        money -= num *10000;
        if(num != 0){
            printQBS(num);
            cout<<"万";
        }
 
        //3、计算元
        num = int(money);
        money -= num;
        if(num != 0){
            printQBS(num);
            cout<<"元";
        }
 
        //4、计算角分
        money = money*100;
        int jiao = money/10;
        int fen = money - jiao*10;
        if(jiao != 0)
            cout<<m_money[jiao]<<"角";
        if(fen != 0)
            cout<<m_money[fen]<<"分";
        cout<<endl;
    }
 
    return 0;
}
~~~

95.表示数字

~~~cpp
#include<stdio.h>
#include<string.h>
int main()
    {
    int i,len;
    char str[1000];
    while(scanf("%s",str)!=EOF)
        {
        len=strlen(str);
        for(i=0;i<len;)
            if(str[i]>='0'&&str[i]<='9')
            {
            printf("*");
            while(str[i]>='0'&&str[i]<='9')
                {
                printf("%c",str[i]);
                i++;
            }
            printf("*");
        }
        else
        {
            printf("%c",str[i]);
            i++;
        }
    printf("\n");
    }
    return 0;
}
//比较好的解法

//检测到数字，则在数字前添加“*”，随即检测后几位，如果检测到字母或其他，则添加“*”
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string a;
    while (cin >> a)
    {
        for (int i = 0; i < a.size(); i++)
        {
            int stop = 0;
            if (isdigit(a[i]))
            {
                a.insert(i,"*");
                i++;
            }
            while (isdigit(a[i]))
            {
                stop = i + 1;
                i++;
            }
            if (stop)
                a.insert(stop, "*");
        }
        cout << a << endl; 
    }
    return 0;
}

~~~

96.记负均正

~~~cpp
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;
int main()
{
    int num;
    while (cin >> num)
    {
        int temp, count = 0, sum = 0, PN = 0;
        vector<int> ivec;
        while (num-- && cin >> temp)
            ivec.push_back(temp);
        for (size_t i = 0; i < ivec.size(); ++i)
            if (ivec[i] < 0)
                count++;
            else if (ivec[i] > 0)
            {
                PN++;
                sum += ivec[i];
            }              
        cout << count << " ";
        cout << fixed << setprecision(1) << (double)sum / PN << endl;
    }
    return 0;
}

~~~

97.自动售货系统

很麻烦，很啰嗦

98.自守数

~~~cpp
#include <iostream>
#include <string>
using namespace std;
//转换成字符串 查找，利用现成的库函数 =-=
int main()
{
    long n;
    while(cin>>n){
        int ans = 2;// 0, 1也是
        for(long i = 3; i<=n; i++){
            long n2 = i*i;
            string s1 = to_string(i);
            string s2 = to_string(n2);
            int pos = s2.size()- s1.size();
            if(s2.find(s1,pos) != -1)
                ans++;
        }
        cout<<ans<<endl;
    }
    return 0;
}
~~~

99.等差数列

S = n*a1+n(n-1)*d/2

100.输入整型数组和排序标识，对其元素按照升序或降序进行排序

~~~cpp
#include <iostream>
using namespace std;
int main()
{
    int Array_Number,Array[10000],iSortFlag,temp;
    while(cin>>Array_Number)
    {
        for(int i=0;i<Array_Number;i++)
            cin>>Array[i];
        cin>>iSortFlag;
        if(iSortFlag==1)//降序排序
        {
            for(int j=0;j<Array_Number;j++)
            {
                for(int k=0;k<Array_Number-j-1;k++)
                {
                    if(Array[k]<Array[k+1])
                    {
                        temp=Array[k];
                        Array[k]=Array[k+1];
                        Array[k+1]=temp;
                    }
                }
            }
        }
        else//升序排序
        {
            for(int j=0;j<Array_Number;j++)
            {
                for(int k=0;k<Array_Number-j-1;k++)
                {
                    if(Array[k]>Array[k+1])
                    {
                        temp=Array[k];
                        Array[k]=Array[k+1];
                        Array[k+1]=temp;
                    }
                }
            }
        }
        //输出排序后的数组
        for(int i=0;i<Array_Number-1;i++)
            cout<<Array[i]<<' ';
        cout<<Array[Array_Number-1]<<endl;
    }
}

链接：https://www.nowcoder.com/questionTerminal/dd0c6b26c9e541f5b935047ff4156309
来源：牛客网

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        vector<int>ivec;
        ivec.clear();
        for(int i=0;i<n;++i)
        {
            int x;
            cin>>x;
            ivec.push_back(x);
        }
        sort(ivec.begin(),ivec.end());
        int choose;
        cin>>choose;
        if(choose==1)
        reverse(ivec.begin(),ivec.end());
        for(int i=0;i<ivec.size()-1;++i)
            cout<<ivec[i]<<' ';
        cout<<ivec[n-1]<<endl;
    }
    return 0;
}

~~~

101,字符统计

~~~cpp
#include <iostream>
#include <map>
#include <algorithm>
 
using namespace std;
 
bool isBigger(const pair<char, int> &lhs, const pair<char, int> &rhs){
    return lhs.second > rhs.second;
}
 
int main(){
    string str;
    while(cin >> str){
        map<char, int> m;
        for(auto c : str)
            ++m[c];
 
        vector<pair<char, int> > pvec(m.begin(), m.end());
        stable_sort(pvec.begin(), pvec.end(), isBigger); // 使用稳定排序, 不能直接使用sort.
 
        for(auto &p : pvec)
            cout << p.first;
        cout << endl;
    }
 
    return 0;
}
~~~

102.redraiment的走法

~~~cpp
//就是求解最长上升子序列

是定义dp[i]为以第i个桩结尾（也就是说最后一个走第i个桩）的最大步数，显然第i个桩肯定从0~i-1的某个桩走来的，当然得满足前面的比后面的矮，所以就在0~i-1的可行桩中选步数最大的 也就是dp[i]=max(dp[i],dp[j]+1) dp[j]=max(dp[0],dp[1],....,dp[i-1])
    
#include<iostream>
#include<stdio.h>
#include<vector>
 
using namespace std; //动态规划
 
int main(){
    int N;
    while(cin>>N){
        vector<int> Data(N,0);
        vector<int> Dp(N,1);
        int ret = 0;
        for(int i=0; i<N; ++i){
            cin >> Data[i];
            for(int j=0; j<i; j++){
                if(Data[i]>Data[j])
                    Dp[i] = max(Dp[i],Dp[j]+1);
            }
            ret = max(ret,Dp[i]);
        }
        cout<< ret<<endl;
    }
    return 0;
}
~~~

103.字符串分割

~~~cpp
#include<iostream>
#include<string>

using namespace std;

int main(){
    int num;
    while(cin >> num){//注意输入多组测试数据，不然通不过
    string str;
    for(int i = 0; i < num;i++){
        cin>> str;
        while(str.size()>8){
         cout<<str.substr(0,8)<<endl;;
          str = str.substr(8);
        }
         cout << str.append(8-str.size(),'0') << endl; 
    }
    }
    
    return  0;
}
~~~

104.计数均正二

~~~cpp
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    int x,count1=0,count2=0;
    double sum=0.0;
    while(cin>>x)
    {
        if(x<0)
            ++count1;
        else
        {
            ++count2;
            sum+=x;
        }
    }
    cout<<count1<<'\n'<<showpoint<<sum/count2<<endl;
    return 0;
}
~~~

105.字符逆序

~~~cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    string str;
    while (getline(cin,str))
    {
        reverse(str.begin(), str.end());
        cout << str << endl;
    }
    return 0;
}
~~~

106.求解立方根

当然用pow函数很不错哟

~~~cpp

牛顿迭代法。设f(x)=x3-y, 求f(x)=0时的解x，即为y的立方根。
根据牛顿迭代思想，xn+1=xn-f(xn)/f'(xn)即x=x-(x3-y)/(3*x2)=(2*x+y/x/x)/3;
    
#include <stdio.h>
inline double abs(double x){return (x>0?x:-x);}
double cubert(const double y){
    double x;
    for(x=1.0;abs(x*x*x-y)>1e-7;x=(2*x+y/x/x)/3);
    return x;
}
int main(){
    for(double y;~scanf("%lf",&y);printf("%.1lf\n",cubert(y)));
    return 0;
}

~~~

107.求最小公倍数

~~~cpp
/* c++
最小公倍数 = 两数之积除以最大公约数
*/
#include<iostream>
using namespace std;
 
int gcd(int a, int b) // greatest common divisor
{
    while(a%b){
        int tmp = a;
        a = b;
        b = tmp%b;
    }
    return b;
 
}
int main()
{
    int a,b;
    while(cin >> a >> b){
        cout << a*b/gcd(a,b) <<endl;
    }
    return 0;
}

~~~



























































