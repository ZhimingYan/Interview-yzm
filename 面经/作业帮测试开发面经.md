### 作业帮测试开发面经

#### 一面

1. tcp的三次握手

   答：

   1. 客户端将标志位SYN置为1，随机产生一个值seq= J,并将该数据包发送给服务端，客户端进入syn_sent状态，等待服务端确认
   2. 服务端收到数据包后由标志位syn = 1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack = J+1,随机残生一个值seq= K，并将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态
   3. 客户端收到数据报后，需要将确认报文发送给服务端表明自己已经收到服务端的建立，进入连接建立状态

2. tcp实现可靠传输的方法

   - 确认应答机制
   - 超时重传
   - 拥塞控制
   - 流量控制
   - 面向字节流

3. tcp的拥塞控制

   TCP的拥塞控制是为了防止过多的数据注入到网络，使得网络中的路由器或者链路过载，流量控制是点对点通信量的控制，而拥塞控制是全局的网路流量整体性的控制，发送双方都有一个拥塞窗口cwnd

   拥塞控制包含四个部分

   - 慢开始

     最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口，每经过一个传输轮次，拥塞窗口加倍，当cwnd超过慢开始的内限，则使用拥塞避免算法，避免cwnd增长过快
     
   - 拥塞避免

     每每经过一个往返时间，cwnd就增长1；

     在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设置为当前值的一半，并且重新设置cwnd为1，重新慢启动

   - 快重传

     接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传

   - 当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到三个重复请求，说明当前网络没有拥塞）

4. socket编程实现tcp的全部过程

   服务端 ： socket ->bind->listen->accept->read->write_close;

   客户端：socket->connect->write->read->close

5. https原理[连接](https://www.jianshu.com/p/14cd2c9d2cd2)

   说起https，我们首先要了解一下密码学，现在有以下解释

   明文：明文指的是 未被加密过的原始数据

   密文：密文通过某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密

   秘钥：秘钥是一种参数，它在明文转化为密文或将密文转化为明文的算法中输入的参数。秘钥分为对称秘钥与非对称秘钥，分别应用在对称加密和非对称加密上面

   - 对称加密：对称加密又叫做私钥加密，即信息的发送方和接受方使用同一个秘钥去加密和解密数据，对称加密的特点是算法公开、加密和解密速度快，适合对大数据量进行加密，常见的加密算法DES,3DES
   - 非对称加密也叫做公钥加密。非对称加密于对称加密相比较，其安全性更好，非对称个加密使用的是一对秘钥，公钥与私钥，，成对出现，私钥自己保存，公钥是公开的，用公钥或私钥中的任何一个进行加密，另一个进行解密
     - 被私钥加密的密文只能公钥加密
     - 被公钥加密过的密文只能被公钥解密

   现在再说一下https的通信过程

   https = http + ssl/tls协议，在数据的传输过程中，需要用SSL/TLS对数据进行加密解密

   ssl: 安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议

   TLS的全称是安全传输层协议

   https为了兼顾安全与效率，同时使用了对称加密和非对称加密，数据是被对称加密纯熟的，对称加密是被对称加密传输的，对称加密的过程需要客户端的一个秘钥为了确保能把该秘钥安全传输到服务器端，采用非对称加密对该秘钥进行加密传输，也就是数据是对称加密的，而对称加密的秘钥进行非对称加密传输

6. 套接字的好处

   根据Socket模块提供的接口函数，进行组合使用完成基于TCP或者UDP的网络编程，套接字就是完成上述目标的一种编程手段，编程方案

7. C++ new、delete的区别

   new/delete是操作运算符，关键字

   new 1. 会分配空间，其次会调用对象的构造函数

   delete  会析构对象，然后释放内存

8. C++内存

   从上到下:

   - kernel
   - 自由存储区：使用malloc分配，使用免费进行挥手，与堆类似
   - 运行时栈:由编译器在需要的时候自动分配和释放，通常用来存储局部变量和函数参数
   - 运行时堆：自己分配，若分配未被释放，会造成内存泄露
   - 未初始化的静态数据bbs
   - 已经初始化的静态变量
   - 常量区：常量数据
   - 程序代码区：存放CPU执行的机器指令
   - init

9. 如何理解C++的三大特性

10. AVL的特性

    - 左右之差不超过1
    - 平衡二叉树一定是二茬搜索树
    - F(n) = F(n-1) + F(n-2) + 1

11. 完全二叉树，有n个节点，求深度

    k = log2(n) + 1;

12. 链表的特点

    - 地址不是连续的
    - 频繁的插入和删除可以使用链表

13. 快排

    ~~~cpp
    void quickSort(int q[], int l , int r){
        if(l >= r) return;
        int i = l - 1, j = r + 1, x = q[l + r >> 1];
        while( i < j){
            do i++; while(q[i] < x);
            do j--; while(q[j] > x);
            if(i < j) swap(q[i] , q[j]);
            
        }
        quickSort(q,l,j);
        quickSort(q,j+1, r);
    } 
    ~~~

    

#### 二面

1. 怎么实现机器人和上位机的通信

   TCP IP通讯协议

2. 二叉树的层序遍历

3. 代码实现洗牌程序

   ~~~cpp
   srand(time(NULL));
   for(int i = 0; i < N ; i++){
       int temp = rand() % (i+1);
       if(temp != i)
           swap((poker[i],poker[temp])
   ~~~

   证明是等概论的

   首先，temp是0~i，概率为1/（i+1），所以temp != i的概率为i/(i+1) 
   其次，temp之前一共有i个数，每个数的概率都是相等的（这里其实可以用数学归纳法），那么每个数被交换的概率是，1/i * i/(i+1) = 1/(i+1) 
   得证。

   

