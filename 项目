项目知识点

京天积木项目

1. 相机驱动的开发
   1. 根据本身内置cobotsys操作系统中basler相机驱动的相机库改写，对AbstractCamera、AbstractShareObject工厂进行继承，并对相关函数进行覆盖.
   2. 使用观察者模式设计一个类
      - 观察者又叫做发布订阅模式，定义了一种一对多的关系，让多个观察者同时监听某一个对象，
        当这个主题对象发生改变的时候，会通知所有观察者对象，使他们能够自动的更新自己   
      - 只有一个相机在工作，因此需要用到相机的时候，只需要注册一个相机的观察者，一旦相机采集到的数据发生实时动态的变化会通知相关的观察者的对象进行更新
      - 举例，出租车打车系统费用的更新，秘书跟老板充当观察者，通知员工开始工作的更新
   3. 使用到的C++语法，多重继承，函数重载，override关键字（子类对父类的覆盖操作）
2. Kinect相机的手眼标定，并利用传统视觉算法进行积木的整体定位
   1. 手眼标定算法 ,在实际控制中，相机检测到目标在图像中的像素位置后，通过标定好的坐标转换矩阵将相机的像素坐标变换到机械手的空间坐标系中，然后根据机械手坐标系计算出各个电机该如何运动，从而控制机械手到达指定位置。这个过程中涉及到了图像标定，图像处理，运动学正逆解，手眼标定等。 
      - 常用的标定方法有：九点标定算法，让机械手的末端去走这就9个点得到在机器人坐标系中的坐标，同时还要用相机识别9个点得到像素坐标。这样就得到了9组对应的坐标。 
      - 使用的是opencv实现的手眼标定算法AX=XB,其中A为机器人末端连杆坐标架在机器人-摄像机系统移动前后的转换关系，B为摄像机坐标架在移动前后的相对关系 
   2. 传统视觉算法
      - 图像的去燥，高斯滤波（低通滤波器），是图像变得平滑；
      - 轮廓提取（对于二值图像而言），findCountes函数，面积过滤，提取中心点
      - 进行调试，主要二维平面信息
3. Yolov3算法进行积木块的识别与定位，并封装darknet深度学习框架将算法集成到软件中去
   1. yolov3算法
      - 算法思想：首先通过特征提取网络对输入图像提取特征，得到一定size的feature map，比如1313，然后将输入图像分成1313个grid cell，接着如果ground truth中某个object的中心坐标落在哪个grid cell中，那么就由该grid cell来预测该object，因为每个grid cell都会预测固定数量的bounding box（YOLO v1中是2个，YOLO v2中是5个，YOLO v3中是3个，这几个bounding box的初始size是不一样的），那么这几个bounding box中最终是由哪一个来预测该object？答案是：这几个bounding box中只有和ground truth的IOU最大的bounding box才是用来预测该object的。
   2. darknet:darknet是一个较为轻型的完全基于C与CUDA的开源深度学习框架，其主要特点就是容易安装，没有任何依赖项（OpenCV都可以不用），移植性非常好，支持CPU与GPU两种计算方式 
      - 由c语言实现，没有使用任何依赖项，opencv只是用来进行显示
      - 支持GPU，比较轻型，可以方便对其进行改进与扩展；
      - 与caffe由许多相类似的地方
   3. 集成方法：将darknet编译成动态库(静态库），提取中检测的相关代码封装成C++类，（使用extern  "C"引入C的库代码，使用的是gcc编译器，在darknet.h 文件中添加了）
      - C++和C在编译后对产生的函数名字的处理是不一样的 ，对于C++编译器, 由于__cplusplus宏被定义, 因此通过extern "C"来通知C++编译器编译后的代码是按照C的obj文件格式编译的，要连接的话按照C的命名规则去找 
      - 多数情况下我们C的库都是SDK(包括头文件和lib包), 没有源代码, 那么在我们的C++代码中使用extern “C”就通知编译器我们引入了C库的代码 
4. 使用多线程技术C++11线程库，控制两个相机两个UR机器人手臂以及力传感器进行协作作业任务
   1. 主要的写的各种C++类有
      - DriverControl类用来整合各种物理设备，为demo控制各设备提供一个整洁的句柄，驱动控制模块
      - DemoController多线程控制模块
      - ExhibitionView    Qt界面控制模块
   2. C++11线程库
      - Linux操作系统提供了四类系统用于多程序程序，分别线程的创建、销毁、线程同步的互斥量（mutex）、条件量（cond），信号量（sem）
      - thread: 线程类thread，提供RAII式线程的创建和销毁。创建线程时传入线程要执行的代码段（函数、lamda表达式）和参数，thread析构函数会自动销毁线程 
      - mutex： std::mutex,普通互斥量，lock(),互斥量加锁，如果互斥量已被加锁，线程阻塞
      - condition_variable: 条件变量的使用要结合条件、互斥量、条件变量三者一起使用。线程在检测条件之前使用mutex加锁，满足某种条件时，线程使用条件变量的wait操作进入阻塞状态。当其他的线程修改条件，激活该条件阻塞的线程，阻塞的线程重新加锁检测条件，条件变量提供wait和notify两种操作
      - C++11多线程库没有提供信号量的类，但是很容易通过条件变量互斥量自己实现
      - 原子操作：针对多线程的共享数据的存储读写，多线程指令交叉可能造成未知的错误(undefine行为)，需要限制并发程序以某种特定的顺序执行，除了前面介绍的互斥量加锁的操纵，还可以使用C++11中提供的原则操作（atomic）。原子操作使得某个线程对共享数据的操作要不一步完成，要不不做。 
      - future: 多线程设计时，一方面要注意多线程共享数据访问的安全性，另一方面有些一步任务之间会有结果的传递。C++11标准提供了几种异步任务处理机制。通常thread不能直接返回执行的结，而在异步处理当中很多时候一个线程创建某个线程处理任务、
      - std::future可用于异步任务中获取任务结果，但是它只是获取结果而已，真正的异步调用需要配合std::async，std::packaged_task，std::promise。async是个模板函数，packaged_task和promise是模板类，通常模板实例化参数是任务函数 
      机器人绘画项目
      1. Qt进行界面的开发工作，实现了软件与denso机器人的实时通信
         1. 关于Qt界面的开发相关面试题,比较好的QT面试题
            - 信号与槽机制
                  /*关于信号的注意事项：
                  1.所有的信号声明都是公共的，所以Qt规定不能在signals前面加public,private, protected。
                  2.所有的信号都没有返回值，所以返回值都用void。
                  3.所有的信号都不需要定义。
                  4.必须直接或间接继承自QOBject类，并且开头私有声明包含Q_OBJECT。
                  5.当一个信号发出时，会立即执行其槽函数，等待槽函数执行完毕后，才会执行后面的代码，如果一个信号链接了多个槽，那么会等所有的槽函数执行完毕后才执行后面的代码，槽函数的执行顺序是按照它们链接时的顺序执行的。
                  6.在链接信号和槽时，可以设置链接方式为：在发出信号后，不需要等待槽函数执行完，而是直接执行后面的代码。
                  7.发出信号使用emit关键字。
                  8.信号参数的个数不得少于槽参数的个数。
                  */
                  
                  /*关于槽的注意事项：
                  1.槽其实就是普通的C++函数，它唯一特点就是能和信号链接。当和它链接的信号被发出时，这个槽就会被调用。
                  2.声明槽可以使用：public/protected/private slots:
                  3.以上是Qt4的做法，在Qt5中你也不需要使用这些声明，每个函数都可以被当作是槽函数，而且还可以使用Lambda表达式来作为槽。不过为了程序的可读性，我还是推荐槽函数要声明一下.
                  */
                  connect(pushButton, SIGNAL(clicked()), dialog,  SLOT(close()));
                  connect(pushButton, QPushButton::clicked, dialog,  QDialog::close);
                  
                  1、QT信号槽机制的优缺点 
                  1）QT信号槽机制的引用精简了程序员的代码量 
                  2）QT的信号可以对应多个槽（但他们的调用顺序随机），也可以多个槽映射一个信号 
                  3）QT的信号槽的建立和解除绑定十分自由 
                  4）信号槽同真正的回调函数比起来时间的耗损还是很大的，所有在嵌入式实时系统中应当慎用 
                  5）信号槽的参数限定很多例如不能携带模板类参数，不能出现宏定义等等
                  
                  3、多线程情况下, Qt中的信号槽分别在什么线程中执行, 如何控制? 
                  可以通过connect函数的第五个参数来控制, 信号槽执行时所在的线程 
                  1>. 直接连接 – 信号槽函数在信号发出者所在线程中执行 
                  2>. 队列连接 – 信号在信号发出者所在线程中执行,槽函数在信号接收者所在线程中执行. 
                  3>. 自动连接 – 多线程时为队列连接方式, 单线程时为直接连接方式 
                  默认情况为自动连接方式.
              
            - 内部字符集采用UNICODE
            - 描述Qt下tcp通信的整个流程
                  服务器端: 
                  1. 创建用于监听的套接字 
                  2. 给套接字设置监听 
                  3. 如果有连接到来, 监听的套接字会发出信号newConnected 
                  4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信) 
                  5. 使用用于通信的套接字对象通信 
                  1>. 发送数据: write 
                  2>. 接收数据: readAll/read 
                  客户端: 
                  1. 创建用于通信的套接字 
                  2. 连接服务器: connectToHost 
                  3. 连接成功与服务器通信 
                  1>. 发送数据: write 
                  2>. 接收数据: readAll/read
                  
                  
                  QT如果要进行网络编程首先需要在.pro中添加如下代码：QT += network 
                  在头文件中包含相关头文件 
                  include QHostInfo 
                  include QNetworkInterface 
            - 线程类
                  Qt 包含下面一些线程相关的类：
                  QThread 提供了开始一个新线程的方法
                  QThreadStorage 提供逐线程数据存储
                  QMutex 提供相互排斥的锁，或互斥量
                  QMutexLocker 是一个便利类，它可以自动对QMutex加锁与解锁
                  QReadWriterLock 提供了一个可以同时读操作的锁
                  QReadLocker与QWriteLocker 是便利类，它自动对QReadWriteLock加锁与解锁
                  QSemaphore 提供了一个整型信号量，是互斥量的泛化
                  QWaitCondition 提供了一种方法，使得线程可以在被另外线程唤醒之前一直休眠
                  
                  
                  还需要注意的是，QT只允许主线程使用界面类，因为界面类不是线程安全的，不可重入，在多个线程中使用可能会出现文图。主线程主要做界面显示，次线程使用signal-slot控制主线程中的界面类，从而间接达到控制目的
              
         2. TCP/IP通信的问题
            - TCP的三次握手/四次挥手
                  第一次握手：客户端发送syn包到服务端，进入sys_send状态，等待服务端确认
                  第二次握手：服务端接收到了syn包，必须确认syn，并且要发送一个syn包，syn+ack,此时服务器进入syn_recv状态
                  第三次握手：客户端接收到了sys+ack包，向服务器发送确认包ack,此包发送完毕，客户端与服务端链接建立
                  
                  
                  第一次挥手：主动关闭方发送一个FIN,主动告诉对方，我不会给你发送数据了，此时发送fin之前的数据没有收到对应的ack确认报文，主动方依然会重发这些数据，主动方还可以接受数据
                  第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为+1(与SYN相同，一个FIN占用一个序号)
                  第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送
                  第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1,完成四次挥手
              tcp如何保证可靠传输
              - 超时重传  发送方在发送某个seq包，等待一段时间如果没收到ack回复，则认为数据包丢
              - 快速重传  接收方主动告诉发送端数据没收到，然后触发重传
              - 流量控制（滑动窗口）  TCP滑动窗流量控制，TCP中的Window,这个字段告诉发送端还有多少缓冲区可以接受，于是发送端可以根据这个来发送，不会导致接收端处理不过来
              - 拥塞控制   是基于整个网络来进行考虑的
         3. 进程与线程的区别
            - 线程共享进程的地址，进程是独立的地址空间
            - 同一进程中的线程共享本进程的资源（内存、I/O、cpu），但是进程之间的资源是相互独立的
            - 进程崩溃不会影响其他进程，线程崩溃则该进程挂掉
            - 执行过程：每个进程有一个程序运行的入口，顺序执行序列和程序入口。但是线程不能独立执行，必须依赖于应用程序中
            - 线程是处理器调度的基本单位，进程是资源分配的基本单位
            - 两者均可并发执行
         4. 多线程与多进程的使用
            - 对资源管理和保护要求高，不限制开销和效率时，使用多进程
            - 要求效率高，频繁切换时，资源保护管理的要求不是很高时使用多线程
         5. 进程与线程之间的通信方式
            - 进程：管道（半双工通信方式）、信号量、消息队列（消息列表存放在队列之中）、共享内存（映射一段能被其他进程所访问的内存）、套接字（可用于不同及其间的进程通信）
            - 线程：全集变量、自定义消息、std::promise与std::future(C++11)搭配使用达到单词数据交换的目的

专业技能

1. 熟悉C++，了解Java,与python
   1. C++与java的区别
      - java没有指针，运行成JVM上，移植性强，在JVM里面运行得到结果，垃圾回收gc算法，有着丰富的插件，而C++在底层和中间件上更有优势，灵活，支持运算符重载和多继承，自动强制类型转换
        
2. 熟悉STL、了解多线程（并发）编程、了解计算机网络
   1. vector使用注意事项
      - 一旦内存重新分配，和vector相关的所有references、pointers/iterators都会失效
      - 内存的重新分配很耗时间，使用push_back向尾部添加元素可能引起整个对象存储空间的重新分配。尽量使用reserve分配内存
      - insert是在所指的元素之前进行插入，erase返回的迭代器指向被最后删除的元素的下一个元素
      - clear只是保证了析构所有的元素，即size()=0，但并不保证释放所有的存储空间，即capacity不一定等于0，可以使用如下方式释放所有内存。 vec.swap(vector<T>());
          3 内存分配器allocator四个主要成员函数和功能简介
          
          （1）allocate：内存分配，仅分配内存，不构造对象。
          
          （2）deallocate：内存释放， 仅释放内存，不析构对象。
          
          （3）construct：在已分配的内存空间中构造对象，仅构造对象。不分配内存。
          
          （4）destroy：在已分配的内存空间中析构已构造的对象，仅析构对象，不释放内存。
          
          （5）调用顺序：allocate->construct->destroy->deallocate
   2. 多线程并发编程
      - 线程池：创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池 
      - 线程的生命周期：新建、就绪、阻塞、死亡
      - 死锁的四个必要条件
        - 互斥：一个资源只能一个进程使用
        - 请求保持：一个进程因请求资源而阻塞，对已经获得的资源保持不放
        - 不剥夺：进程已获得的资源，未使用完成之前，不能强行剥夺
        - 循环等待：若干进程形成头尾链接的循环等待关系
        
   3. 负载均衡
      - 将用户分摊到多个服务器上
   4. 计算机网络
      - tcp中的socket套接字
3. 熟悉常用的数据结构与算法，了解常用的设计模式
   1. 抽象工厂模式:抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象 
      - 在不必指定产品的具体的情况下，创建多个产品族中的产品对象 
   2. 工厂方法模式：封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用以及方便后期维护拓展的目的 
      - 对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品来 
   3. 策略模式： 定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。Strategy 可以使算法独立于使用算法的客户端 
4. 熟悉常用的数字图像处理算法以及OpenCV库，了解深度学习相关框架
   1. 常用的数字图像处理算法
      - 图像滤波算法：中值滤波、均值滤波、高斯滤波（低通滤波）
      - 图像增强：Sobel算子、拉普拉斯算子、canny算子
            1、sobel算子中引入了类似于局部平均运算，因此对噪声具有平滑作用
            2、拉普拉斯算子对孤立的像素的响应要比边缘或者线的响应应要更加强烈，因此适合无噪声图像（使用之前要进行低通滤波操作）
            3、Canny算子求边缘点具体算法步骤如下：
            1. 用高斯滤波器平滑图像．
            2. 用一阶偏导有限差分计算梯度幅值和方向
            3. 对梯度幅值进行非极大值抑制（指寻找像素点局部最大值，沿着梯度方向，比较它前面和后面的梯度值）
            4. 用双阈值算法检测和连接边缘．
        
      - 形态学操作：腐蚀膨胀，开运算（先腐后膨，用于去除物体外的小白点）闭运算（先膨后腐，去除屋头中的黑洞）
   2. opencv
      - opencv中的基本模块
        - cv       核心代码库
        - cvaux      辅助函数库
        - cxcore     数据结构与线性代数库
        - highgui    GUI函数库
        - ml           机器学习库
   3. 深度学习框架与深度学习算法
      - darknet、 tenserflow、caffe
      - 深度学习算法：SVM、过拟合问题，ssd
5. 熟悉常用的linux系统操作指令
   1. linux基础
      - Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别 
        - 同步：我调用一个功能，该功能没有结束前，我死等结果。异步：不需要知道该功能结果，该功能有结果后通知我（回调通知） 
          阻塞：没有接收完数据或者没有得到结果之前，我不会返回。非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者
        - 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞；阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回 
        - 5种IO模型：同步（阻塞IO，非阻塞IO（会返回错误，然后IO操作函数会不断测试是否准备好，会占用很多cpu时间），IO复用（select，poll，epoll函数，能实现多个IO操作的阻塞，同时对多个IO函数进行检测），信号驱动IO（不阻塞，考sigio信号）），异步I/O（通过状态、通知和回调来通知调用者的输入输出操作） 
      - IO复用的三种方法（select,poll,epoll高并发多连接时好）深入理解，包括三者区别，内部原理实现？ 
        链接
   2. linux常见的命令
      - kill杀死进程、ps查看进程、top查看cpu，内存的使用情况
      - ls 、ls -a（显示隐藏）、ls -l（显示权限）、touch(创建空文件)、、cat（查看文件内容）、rm(-r   递归删除， -f 强制删除)、find(文件系统中搜索某个文件)、wc（统计文本中行数、字数、字符数）、grep(在文本文件中查找某个字符串)、rmdir(删除空目录)、tree(树形显示目录)、pwd(显示当前目录)、ln（创建连接文件）
