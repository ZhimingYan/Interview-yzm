### 项目可能会问答的问题

首先我们要掌握以下面试技巧：

 首先如果可以现场面，推荐现场面试，优势在于能够让面试官看到你的精气神，确保面试期间精神饱满，富有交流欲，尤其和面试官保持眼神交流，让他看到你的态度，并且对于每个问题，不管会不会，多问问面试官总是没错的。这个我认为是最重要的，每次面试官问的问题，我一般都是紧盯这面试官说，我是这么考虑的，您看看对不对/我对这一块不是特别熟悉，但我是这么想的，麻烦您指点一下/对于这个问题，我们分成三部分考虑，首先…
 有人说面试变成了一站到底，这是很难避免的，面试官为了追求效率，考察你是否具备他们所要的技能，那么语言基础、网络、数据库、算法、linux基础，都必须至少两三个问题，于是他们就一个一个蹦出来。这种时候，你最好要稳住节奏，表现出足够的表现欲，对擅长的问题进行扩展，深挖，让面试官意识到你在某一方面很厉害，促使他去按照你想的方向去了解。聚个栗子，面试官问是否了解linux的IO模型，我一般是这么回答的，“对于这个问题，我们首先要理解同步异步、阻塞非阻塞的概念，balabala，他们之间的区别可以类比为XXX。在理解这些之后，我们将IO模型分为五类，分别是XXX”，讲完这些估计就要五分钟，相比你不咸不谈说，有五种，是XXX，面试官不详细问它们的特点你就不说，是不是差距很大。假设我有点忘记了IO模型的分类，那么前面的铺垫是不是也可以给自己时间去回忆。我经常是在面试期间忘了某个问题的答案，于是一边打打擦边球，一边大脑快速回忆这个问题，很可能在讲着讲着就想起来了。即是你想不起来，也绝对你比支支吾吾说不了几个字强太多了。

计算机网络比较好的博文：

1. [三次握手四次挥手及面试常见网络相关问题](https://www.cnblogs.com/amyleell/articles/9235594.html)
2. [详解TCP三次握手四次挥手过程、TCP的可靠性传输以及粘包问题](https://blog.csdn.net/cx2479750196/article/details/81223768)

####  一、高性能网络库NetServer开发https://www.cnblogs.com/amyleell/articles/9235594.html

1. 这是一个什么样的项目，你是如何测试它的性能的；

   这是我在自学Linux网络编程写的一个小项目，后面看过muduo写的一个小项目，因为之前做过一点有关图像处理的一个小项目，所以想后台处理图像，然后在将图像处理的结果显示在网页上，后来由于去实习去了，所以这一块一直没做。这个项目借鉴了muduo的写法，实现了底层网络库的封装，以及简单的http静态页面的编写。可以实现高并发连接

2. 什么是吞吐量，什么是最大连接数

   吞吐量：就是单位时间内通过某个网络信道和接口的数据量，吞吐量收到网络带宽的限制

   最大连接数：进行TCP连接的最大数目

3. 你是如何设计日志系统的，日志级别的有哪些

   - 客户端与服务端日志的有什么区别呢？

     客户端程序的日志一般可以直接在所在的工作线程写日志，因为这点性能和时间损失对于大多数的客户端程序来说，是可以忽略的，但是对于要求高并发，比如量高达百万级乃至千万级的系统的服务端程序内，单位时间内耗在磁盘写操作上的时间就很多了。
     
   - 你是怎么实现自己的日志的

     使用一个队列，需要写日志的时候，当需要写日志的时候将日志加入到队列中。另外一个专门的日志线程来写日志

   - muduo 中日志库是如何实现的

     - 首先多线程程序对日志库提出了新的安全，线程安全，即多个线程可以并发的写日志而不会出现混乱。

     - 的线程安全是如何处理的

       一个全局变量锁进行IO保护，或者一个线程单独写一个日志，前者会造成多个线程争夺锁，后者会造成业务线程阻塞在磁盘操作上面

     - muduo中使用一背景线程负责收集日志消息并写入到后端，其他的业务只负责生成日志消息并将其传输到日志线程（前端），这就叫异步日志

     - muduo 中具体的 技术双缓冲技术

       先设置两个缓冲区，前者网当前缓冲区中https://www.cnblogs.com/amyleell/articles/9235594.html写入日志消息，后端负责将其写入到日志文件中。具体就是当前缓冲区写满，将当前缓冲区的日志消息存入到bufs，当前缓冲区与下一个缓冲中再交换（移动语义），这样前端可以继续往当前线程写入日志，然后在通知后端可以将日志写入到日志文件中

     - 建立两个buff的好处就是新建日志消息的时候不必等待磁盘文件操作，也避免每条日志都粗发了后端日志线程，将多条日志弄成一个大的buffer,在写入到日志文件中，这样就减少了日志被出发的次数，降低了开销

4. 线程池是如何设计的，为什么要设计线程

   线程池的设计就是生产者与消费者问题，外部线程生产任务添加到任务队列中，线程池中的线程一旦有线程就唤醒线程，对任务进行处理

   - 外部线程生产任务添加到任务队列中，这里的https://www.cnblogs.com/amyleell/articles/9235594.html任务队列没有最大限制
   - 任务队列中有一旦有任务会通知线程池线程进行处理，并且是先来到的任务先处理，任务没有优先级，故使用的数据结构是队列，这里使用的是双端队列
   - 主要的流程就是 
     1. 构造线程池对象
     2. 启动（start）线程池，这里其实做了两件事，一个是设定了线程池的大小，一个是构造设定数目的线程对象到线程池中，并启动每个线程
     3. (run)运行线程池，也就是往线程池中丢任务进去
     4. 线程池中有任务了就运行执行任务，调用外部定义的函数，也就是执行任务的逻辑

5. 你是否了解linux系统的IO模型，什么是阻塞与非阻塞？异步与同步的概念？

   对于这个问题，我们首先要理解同步异步，阻塞非阻塞的概念。

   - 其中同步异步关注的是消息通讯机制，所谓的同步就是在发出一个调用时，在没有得到结果之前该调用就不返回，但是一旦调用返回了就得到了返回值了。一句话来理解就是调用者主动等待这个调用的结果，而异步是相反的，在调用之后，这个调用就直接返回了，所以没有返回结果，换句话讲就是当一个异步调用发出后，调用者不会立刻得到结果，而是在调用发出之后，被调用着通过状态，通知来通知调用者，或者用回调函数来处理这个调用

   - 阻塞非阻关注的则是程序在等待调用结果时的状态，阻塞调用时指调用结果返回之前，当前线程挂起，调用线程只有在结果之后才会返回，而非阻塞指在不能立刻得到结果之前，该调用不会阻塞当前

     简单点理解：

     1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
     2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。
     3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
     4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

     同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞

     阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回

6. 你这个项目为什么要用非阻塞式IO

   - select、poll_wait、epoll_wait返回可读≠read去读的时候能读到（因为select和read是两个独立的系统调用）。如果不用非阻塞，程序会永远卡在read上。以上情况可能出现在多进程同时监听一个socket，只有一个进程可以accept，别的都会block（惊群效应）
   - 假如socket的读缓冲区已经有足够多的数据，需要read多次才能读完，如果是非阻塞可以在循环里读取，不用担心阻塞在read上，等到errno被置为EWOULDBLOCK的时候break，安全返回select。但如果是阻塞IO，只敢读取一次，因为如果读取没有数据的fd，read会阻塞，无法返回select，这样就只能期待着多次从select返回，每次只读一次，效率低下。而且，如果是ET模式，还会造成数据无人处理，导致饥饿。

7. 同步IO和异步IO

   同步IO于异步IO的区别就是同步IO进行IO操作会阻塞进程。

   同步IO指的是 必须等待IO操作完成之后，控制才返回给用户进程。异步IO指的是无需等待IO操作完成就将控制权交给用户进程，处理完成之后内核会向用户进程发送一个信号，返回read操作已经完成的信息，然后将数据拷贝给用户层。

8. 阻塞与非阻塞

   阻塞与非阻塞的概念描述的是用户线程调用内核IO的操作方式：阻塞是只IO操作需要彻底完成候才会返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，不需要等待IO操作彻底完成

9. 为什么说非阻塞IO网络编程中应用层buffer是必须的

   多路复用的思想就是用一个线程去同时对多个socket连接服务(传统的模式是一个线程或者进程只对一个连接服务)，而想要做到这一点，线程或者进程就不能阻塞到某一个socket的read或write上面，就要用到非阻塞IO，应该阻塞到epoll_wait上面

   那么现在假设你要向一个socket发送100kb的数据，https://www.cnblogs.com/amyleell/articles/9235594.html但是write调用中，操作系统只接受了80kb的数据，原因可能是受制于TCP的流量控制等等，现在你有**两个选择** ：

   1. 等——你可以while这个write调用，但你不知道要等多久，这取决于对方什么时候收到之前的报文并且滑动窗口，而且这样也浪费了处理别的socket的时间。
   2. 把剩下的20kb存起来，下次再发，具体一点就是把这20kb保存在这个TCPconnection的output buffer里，并且注册POLLOUT事件，这样select下次返回的时候就还会来发送这20kb的数据，也不会影响别的socket的监听。

   若20kb发送之前，又有数据要write，则应该append到缓冲区尾部，否则可能造成乱码
   POLLOUT可写事件到来是由操作系统的发送缓冲区有空触发的，同理EPOLLIN事件是操作系统接收缓冲区有数据触发的
   若缓冲区为empty，则应该停止关心POLLOUT事件https://www.cnblogs.com/amyleell/articles/9235594.html，否则可能会busy loop（但是epoll的ET模式下不会再次提醒，就没有这个问题）
   至于为什么需要inputbuffer， 那是因为TCP是一个没有边界的字节流协议，不可能一个数据报就是一个请求。

10. 你是如何设计定时器的，为什么不适用sleep与unsleep

11. 什么是基于对象编程，什么是面向对象编程

    - 面向对象有以下的特点：
      - 会暴露抽象类
      - 利用虚函数的多态性回调相应的接口
      - 类内部使用static函数作为线程入口函数，需要将当前线程的this指针作为pthread_create()的第四个参数传入到线程内部（这里主要体现在一个一个普通成员函数一般是无法被静态成员函数调用的）
    - 基于对象的特点
      - 只使用具体类，不暴露抽象类

12. TCP相关的问题
    - tcp的三次握手（为什么不是四次或者两次），tcp的四次挥手(为什么不是三次)

    - 什么是优雅关闭连接

      shutdown优雅的关闭连接，会等待缓冲区的数据传输完毕再发送FIN包，就意味着，调用close将丢失缓冲区中的数据，而调用shutdown不会，比较优雅的关闭连接，而不至于太过生硬

    - close与shutdown的区别

      TCP连接是全双工的连接，及连接双方可以并行的发送或者接收消息。这样关闭连接时就存在3种情形：完全关闭连接； 关闭发送消息的功能；关闭接收消息的功能。其中，后者就叫做半关闭，由shutdown实现，前者用close实现。

      close/closesocket是用来关闭套接字，将其从内存中清除，之后再也不能使用，应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。

      shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。

      调用 close()/closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。

      默认情况下，close()/closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。
    
    
- 什么是半关闭状态，tcp的状态转换关系图怎么画
  
  因为TCP连接是全双工的，所以它允许两个方向的数据传输被独立的关闭，换句话说，通信的一端可以发送结束报文文给对方，告诉它本端已经完成了数据的发送，但是允许接受来自对方的数据，直到对方也发送结束报文段以关闭连接，这种状态就叫做半关闭状态，shutdown函数提供了对半连接的支持
  
- TCP为什么是可靠的连接
  
  - 首先TCP发送应答机制，也就是发送端发送的每个TCP报文都必须得到接收方的应答，才认为这个TCP报文端传输成功
  - 其次，TCP协议采用超时重传机制，发送端发送TCP后会启动定时器，如果在定时间内未收到应答，会重新发送该报文
  - 最后TCP报文段最终以IP数据报发送的，而IP数据报到达接收端可能乱序，重复，所以TCPx协议会将接受到的TCP报文段重排整理在交付给应用层
  
- TCP为什么会有粘包问题，你是如何解决的
  
  因为TCP是字节流传输，因此会造成两个包黏在一起，因此需要进行TCP的分包操作
  
  当然对于短连接的TCP服务，分包不是个问题，只要发送方主动关闭连接一条消息就发送完毕了
  
  长连接的TCP分包
  
  1. 消息固定长度
  2. http协议中\r\n为字段的分隔符
  3. 在每条消息的头部加一个长度字段，这个是常见的用法
  4. 利用消息本身的格式，比如xml,json的陪读截止
  
- TCP与UDP的区别
  
  - TCP是面向连接、字节流的可靠传输，而UDP是面向无连接的不可靠的连接
  - TCP的连接是一对一的，UDP则是多播和广播
  - TCP保证准确无误的传输，而UDP是尽自己最大可能传输
  
- 你抓过包没有，你用的是什么工具
  
- aTCP有关的api有哪些，服务端与客户端上面分别是什么，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？
  
- TCP长连接与短连接的区别
  
  TCP的短连接就是发送一次数据之后就关闭，http1.0就支持短连接
  
  TCP的长连接就是发送数据之后不会关闭连接，而是连接复用减少了三次握手所要的开销。http1.1就是一定时间限制于次数限制的长连接。当然发送完之后，为了连接不断开，会一定时间间隔内会发送心跳包以保证该连接在运行
  
- TIME_WAIT的意义（为什么要等于2MSL）
  
  客户端收到服务器的结束报文，第三次挥手阶段，并没有直接进入closeed状态,而是TimeWaite状态，客户端连接要等待2MSL（报文端的最大生命周期2分钟）
  
  存在的原因：
  
  - 可靠的终止TCP连接（如果最后一个ACK报文段丢包了，最后服务器将重新发送结束报文）
  
  - 保证让迟来的TCP报文段有足够的时间被识别和丢弃
  
    Linux系统上TCP的端口不能同时打开两次，如果有TIMEWAIT状态，我们无法使立即使用该链接占用的端口来重新建立一个新连接，如果不存在，就会建立一个于刚关闭连接相似的连接，会接受到原来的连接现代引用程序的报文段，这是不应该发生的
  
  2ML是为了确保两个方向上的尚未接受的迟到的报文段都已经消失
  
- 超时重传机制（不太高频
  
  跟上面的可靠连接一起答
  
- TCP怎么保证可靠性（面向字节流，超时重传，应答机制，滑动窗口，拥塞控制，校验等）？
  
- 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？
  
- tcp滑动窗口协议
  
- 拥塞控制和流量控制的区别
  
  流量控制：
  
  如果应用程序读取数据相当的慢，而发送方发送数据太多太快，会容易使得接收方的缓存溢出，流量控制的就是用来发送数据与接受数据的匹配。发送方维护一个接受窗口变量，这个变量表示接受方向可用的缓存空间
  
  
  
- TCP拥塞控制，算法名字？（极其重要）
13. 并发模型相关的问题
    - 什么是reactor模式，请说一下它的组成

      reactor模式主线程只负责监听文件描述上是否有事件间发生，有的话就立即将该事件通知工作线程，初次之外，主线程不做任何实质性的工作，读写数据接受新的连接以及处理客户端请求均在工作线程中进行

      使用同步IO模型实现的Reactor模式的工作流程是

      1. 主线程往epoll内核事件表中注册socket上的读就绪事件
      2. 主线程调用epoll_wait等待socket上有数据可读
      3. 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入到请求队列中
      4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的读就绪事件
      5. 主线程调用epoll_wait等待socket可写；
      6. 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入到请求队列当中
      7. 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

    - 你还知道有哪些并发模型，他们有什么缺点与优点

      ![reactor_comparison](http://hi.csdn.net/attachment/201106/16/0_1308200575Ru88.gif)

      具体参考我博客：https://blog.csdn.net/qq_40028201/article/details/90547770

      先主要介绍一下有关reactor的几种

      1. Reactor单线程模型：所有的IO操作都在同一个NIO线程上面完成

         - NIO服务端，接受客户端的TCP连接
         - NIO客户端，向服务端发起TCP连接
         - 读取通信对端的请求或者应答消息；
         - 向通信对端发送消息请求或者应答消息。
         - 链路过多，单线程无法支撑，所以适合一些并发连接数较小的场景
    
      2. Reactor多线程模型：Rector多线程模型与单线程模型最大的区别就是有一组NIO线程处理IO操作
    
         - 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；
         - 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送
         - 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。
    
      3. 主从多线程模型
    
         服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。
    
    - 你知道Nginx么，他么是优雅关闭连接是怎么工作的，跟你设计的有什么不同
    
    - 请你设计一下单线程方式处理高并发能力
    
      使用IO多路复用来处理高并发能力
    
    - 请你说一说select，epoll的区别，原理、性能限制说一说
    
    - epoll中水平触发与边沿触发有什么区别
    
      水平触发
    
      特点是：如果用户在监听epoll事件，当内核有事件的时候，会拷贝给用户态，但是如果用户只处理了一次，那么剩下的没有处理的会在下次epoll——wait再次返回该事件
    
      后果是：如果用户永远不处理这个事件就会导致每次都会有该事件从内核到用户的拷贝，耗费性能，但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕
    
      边沿触发
    
      跟水平粗发想法，当内核有时间到达，只会通知用户一次，如果用户不处理，以后将不会通知。这样减少了拷贝过程，增加了性能，但是 相对来说，如果用户马虎忘记处理，将会产生事件丢的情况
    
      
    
14. 如何实现一个无锁队列（原子操作）

15. 线程有哪些唤醒方式

16. 任务队列是怎么实现的，除了加锁还有什么方式？

17. 你是如何解决死锁的

18. eventfd是什么，有什么好处

    eventfd是linux2.6.27后面假的一个新的特性，使用来实现多线程多进程之间的通信的,它是一个比pipe更加高效的线程间通知机制，一方面它比pipe少用一个fd节省了资源，另一方面，evenntfd的缓冲区管理也简单得多，去不buffer只有定长8bit不像 pipe 那样可能有不定长的真正 buffer。

    更重要的一点：当我们想要编写并发型服务器的时候，eventfd 可以完美取代 pipe去通知(唤醒)其他的进程(线程)。比如经典的异步IO reactor/selector 应用场景，去唤醒select的调用。可以和事件通知机制完美的的结合（参考博客https://blog.csdn.net/NK_test/article/details/51138359）

    接口

    ~~~Cpp
    #include <sys/eventfd.h>
    int eventfd(unsigned int initval, int flags);
    ~~~

19. 用到了哪些智能指针，RAII机制

20. 互斥锁、读写锁、互旋锁有什么区别

21. 你是怎么进行压力测试的

22. 项目过程中你遇到了哪些困难，你认为哪些是难点，你是怎么解决的

23. 你是怎么检测内存泄漏的

24. 怎么进行压力测试的

25. http协议，具体参考一下https://blog.csdn.net/weixin_39780047/article/details/88850857

    1. http报文有哪些字段
    2. http状态码有哪些
    3. 网页解析的过程与实现方法
    4.  http中浏览器一个URL的流程，这个过程中浏览器做了什么，URL包括哪三个部分？
    5.  http协议与TCP联系
    6. http/1.0和http/1.1的区别
    7. http的请求方法有哪些？get和post的区别。
    8. http和https的区别，由http升级为https需要做哪些操作
    9. https的具体实现，怎么确保安全性
    10. 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？
    11. 对称密码和非对称密码体系
    12. 服务器攻击（DDos攻击）
    13. 多线程同步

#### 二、机器人相关的项目

1. 这个项目有什么难点

2. 这个项目用到了什么样的设计模式

   - 介绍一下工厂模式和单例模式，观察者模式

3. 线程是怎么设计的

4. yolov3算法介绍一下，

5. 用到了哪些C++11的知识

6. 能说说常用的图像处理算法么

   - 图像增强

     - sobel算子
     - 拉普拉斯算子
     - canny

   - 图像滤波

     - 高斯滤波
     - 中值滤波
     - 均值滤波

     

     



